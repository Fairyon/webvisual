<!-- Using d3.js-library -->

<dom-module id='chart-element'>
  <template>
<style>
  :host {
    display: inline-flex;
    width: auto;
    height: auto;
    flex: 1;
    position: relative;
    align-self: stretch;
    box-sizing: border-box;
    font-family: inherit;
    font-size: 0.75em;
    color: currentColor;
    letter-spacing: normal !important;
    border-radius: inherit;
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
    -webkit-touch-callout: none; -webkit-tap-highlight-color:rgba(0,0,0,0);
  	/*overflow: hidden;*/
    visibility: visible;
    -webkit-touch-callout: none !important;
      -webkit-user-select: none !important;
       -khtml-user-select: none !important;
         -moz-user-select: none !important;
          -ms-user-select: none !important;
              user-select: none !important;
  }
  div#svgContainer {
    display: inline-flex;
    position: relative;
  }
  button-element {
    padding: 0.5em;
    border-radius: 0px;
  }
  .icon-button, section#info {
    position: absolute;
    opacity: 0.75;
    transition: opacity 250ms ease;
  }
  .icon-button:hover, section#info:hover {
    opacity: 1;
    border-radius: 0;
  }
  section#info {
    padding: 0.75em;
    line-height: 1;
  }
  section.infotext {
    margin-bottom: 0.5em;
  }
  text {
    fill: currentColor;
    pointer-events: none;
    font-weight: normal; !important;
    letter-spacing: normal !important;
    @apply(--font-common-base);
  }
  g#chart text{
    font-size: 1em;
  }
  g#brush text{
    font-size: 0.5em;
  }
  g#chart rect.plot {
    fill: white;
    fill-opacity: 0.7;
    stroke: currentColor;
    stroke-opacity: 0.25;
    shape-rendering: crispEdges;
    stroke-width: 1px;
  }
  g#brushX rect.background, g#brushY rect.background {
    fill: white;
    fill-opacity: 0.8;
    stroke: currentColor;
    stroke-opacity: 0.25;
    stroke-width: 1px;
  }
  g.grid g.tick line {
    stroke: currentColor;
    stroke-opacity: 0.1;
  }
  g.grid path {
    stroke-width: 0;
  }
  g.axis path, g.axis line {
    fill: none;
    stroke: currentColor;
    stroke-opacity: 0.25;
    stroke-width: 1.5px;
  }
  g#chart g.axis path, g#chart g.axis line {
    stroke-opacity: 0.5;
  }
  g#focus line.focus.line {
      fill: none;
      stroke: currentColor;
      stroke-opacity: 0.3;
      stroke-width: 2px;
      stroke-dasharray: 5;
  }
  g.brush rect.selection {
    stroke: #345475;
    fill: #005B82;
    stroke-opacity: 0.5;
    fill-opacity: 0.25;
  }
  g.brush rect.selection.clamp {
    fill-opacity: 0.3;
    stroke-opacity: 0.6;
  }
</style>
<div id="svgContainer">
  <svg id='svg' version='1.1' xmlns='http://www.w3.org/2000/svg'>
    <g id='brushX'>
      <rect class='background'></rect>
      <g class='axis'></g>
      <g class='brush'></g>
    </g>
    <g id='brushY'>
      <rect class='background'></rect>
      <g class='axis'></g>
      <g class='brush'></g>
    </g>
    <g id='chart'>
      <clipPath id='clip'>
        <rect x='0' y='0'></rect>
      </clipPath>
      <rect class='plot'></rect>
      <g class='x axis'></g>
      <g class='y axis'></g>
      <g class='x grid'></g>
      <g class='y grid'></g>
      <g id='graphs'></g>
      <!-- <g id='focus'>
        <line class='focus line x' y1='0'></line>
        <line class='focus line y' x1='0'></line>
        <text class='focus text x' y='4'></text>
        <text class='focus text y' x='4'></text>
      </g> -->
    </g>
  </svg>

  <section id='info' on-tap='_toggleInfo' hidden>
    <section id='infoX' class="infotext"></section>
    <section id='infoY' class="infotext"></section>
  </section>

  <icon-button-element id="menubutton" class="icon-button" icon="timeline"></icon-button-element>
  <dropdown-element id="legend" for="menubutton" target-toggle-event="tap" position="bottom" align="outer-start">
    <toggle-button-element checked="[[!noDots]]" on-change="changeDots"></iron-icon>mit Punkten</toggle-button-element>
    <toggle-button-element checked="[[!noLines]]" on-change="changeLines"></iron-icon>mit Linien</toggle-button-element>
    <toggle-button-element checked="[[!noAreas]]" on-change="changeAreas">mit Flächen</toggle-button-element>
  </dropdown-element>

  <dropdown-selector id="ybutton" class="icon-button" icon="y" hide-selected attr-for-selected="scale" selected="{{yScale}}" fallback-selection="linear" toggles hide-arrow position="bottom" align="outer-end">
      <button-element scale='linear'>linear</button-element>
      <button-element scale='√'>√</button-element>
      <button-element scale='ln'>ln</button-element>
      <button-element scale='log₁₀'>log₁₀</button-element>
  </dropdown-selector>

  <dropdown-selector id="xbutton" class="icon-button" icon="x" hide-selected attr-for-selected="interpolate" selected="{{interpolation}}" fallback-selection="Lineare Verbindung" toggles hide-arrow position="left" align="end">
      <button-element interpolate='Lineare Verbindung'>Lineare Verbindung</button-element>
      <button-element interpolate='Basis Spline'>Basis Spline</button-element>
      <button-element interpolate='Monotoner Spline'>Monotoner Spline</button-element>
      <button-element interpolate='Kubischer Spline'>Kubischer Spline</button-element>
      <button-element interpolate='Cardinaler Spline'>Cardinaler Spline</button-element>
      <button-element interpolate='Catmull-Rom-Spline'>Catmull-Rom-Spline</button-element>
      <button-element interpolate='Stufe (mitte)'>Stufe (mitte)</button-element>
      <button-element interpolate='Stufe (davor)'>Stufe (davor)</button-element>
      <button-element interpolate='Stufe (danach)'>Stufe (danach)</button-element>
  </dropdown-selector>

</div>
<section id="content">
  <content id='collector' select='graph-element'></content>

  <template is="dom-repeat" items="{{selectedElements}}">
    <graph-element id="[[item.id]]" label="[[item.label]]" caption-keys="[[item.captionKeys]]" color="[[item.color]]"
      values="[[item.values]]" no-dots="[[noDots]]" no-line="[[noLine]]" interpolation="[[interpolation]]" no-areas="[[noAreas]]">
    </graph-element>
  </template>
</section>

</template>

  <script>
    ChartElement = Polymer({
      is: 'chart-element',

      behaviors: [
        ContainerBehavior,
        Polymer.IronResizableBehavior
      ],

      properties: {
        notify: {
          type: Boolean,
          value: false
        },
        notifyParent: {
          type: Boolean,
          value: false
        },
        noSelectNotify: {
          type: Boolean,
          value: false
        },
        noExceedNotify: {
          type: Boolean,
          value: false
        },

        multiSelect: {
          type: Boolean,
          value: true
        },
        toggles: {
          type: Boolean,
          value: true
        },

        reproduce: {
          type: Boolean,
          value: true
        },
        reproductionContainer: {
          type: String,
          value: 'content',
          readOnly: true
        },

        margin: {
          type: Object,
          value: function() {
            return {  top: 0,
                      right: 0,
                      bottom: 36,
                      left: 36 };
          }
        },
        brushWidth: {
          type: Number,
            value: 36
        },
        clamp: {
          type: Boolean,
          value: true
        },
        clampExtend: {
          type: Number,
          value: 16
        },
        _isClamping: {
          type: Boolean,
          value: false
        },
        ticks: {
          type: Number,
          value: 5
        },
        gridMult: {
          type: Number,
          value: 2
        },
        xScale: {
          type: String,
          value: 'time',
          observer: 'changeScale'
        },
        yScale: {
          type: String,
          value: 'linear',
          observer: 'changeScale'
        },
        interpolation: {
          type: String,
          value: 'Monotoner Spline',
          observer: 'changeInterpolation'
        },
        noDots: {
          type: Boolean,
          value: false
        },
        noLines: {
          type: Boolean,
          value: false
        },
        noAreas: {
          type: Boolean,
          value: false
        },
      },

      _width: 0,
      _height: 0,

      _chart: Object,
      _svg: Object,

      _x: Function,
      _x2: Function,
      _y: Function,
      _y2: Function,

      _xAxis: Object,
      _yAxis: Object,
      _xGrid: Object,
      _yGrid: Object,

      _brushBehaviorX: Object,
      _brushX: Object,
      _brushAxisX: Object,
      _brushGridX: Object,

      _brushBehaviorY: Object,
      _brushY: Object,
      _brushAxisY: Object,
      _brushGridY: Object,

      _focus: Object,
      _focusX: Object,
      _focusTextX: Object,
      _focusY: Object,
      _focusTextY: Object,

      _legend: Object,
      _info: Object,

      formatMillisecond: Function,
      formatSecond: Function,
      formatMinute: Function,
      formatHour: Function,
      formatDay: Function,
      formatWeek: Function,
      formatMonth: Function,
      formatYear: Function,
      _elements: [],

      get _self () {
        return this;
      },

      get _parent () {
        if (this.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          return this.parentNode.host;
        }
        return this.parentNode;
      },

      listeners: {
        'iron-resize': '_sizeChanged'
      },

      created: function() {
        d3.timeFormatDefaultLocale({
          'dateTime': '%x %X',
          'date': '%d.%m.%Y',
          'time': '%H:%M:%S',
          'periods': ['', ''],
          'days': ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
          'shortDays': ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
          'months': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
          'shortMonths': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Agu', 'Sep', 'Okt', 'Nov', 'Dez']
        });
        d3.formatDefaultLocale({
          "decimal": ",",
          "thousands": ".",
          "grouping": [3],
          "currency": ["", "\u00a0€"]
        });
        this.formatMillisecond = d3.timeFormat(":%S.%L");
        this.formatSecond = d3.timeFormat(":%S");
        this.formatMinute = d3.timeFormat("%H:%M");
        this.formatHour = d3.timeFormat("%X");
        this.formatDay = d3.timeFormat("%d.%m");
        this.formatWeek = d3.timeFormat("%d.%m");
        this.formatMonth = d3.timeFormat("%d. %b");
        this.formatYear = d3.timeFormat("%Y");
      },

      ready: function() {
        this._buildLayout();
      },

      attached: function() {
        this._observer =
            Polymer.dom(this.$.collector).observeNodes((function(info) {
          this.__processNewNodes(info.addedNodes);
          this.__processRemovedNodes(info.removedNodes);
        }).bind(this));
      },

      __processNewNodes: function(nodes) {
        this._elements = nodes.concat(this._elements || []);
      },

      __processRemovedNodes: function(nodes) {
        this._elements = this.getEffectiveChildren();
      },

      _sizeChanged: function(e) {
        this.debounce('resize', this._sizeLayout, 50);
      },

      _buildLayout: function() {
        this.assignParentResizable(this.rootElement);

        this._svg = d3.select(this.$.svg).attr('preserveAspectRatio', 'xMinYMin meet')
                                         .attr('height', null)
                                         .attr('width', null);
        this._x  = this._createScale(this.xScale);
        this._x2 = this._createScale(this.xScale);
        this._y  = this._createScale(this.yScale);
        this._y2 = this._createScale(this.yScale);

        this._chart = d3.select(this.$.chart);
                        // .on('mouseenter', this._showFocus.bind(this))
                        // .on('mousemove',  this._updateFocus.bind(this))
                        // .on('mouseleave', this._hideFocus.bind(this));

        this._focus = d3.select(this.$.focus)
                        .attr('clip-path', 'url(#clip)');
        this._focusX = this._focus.select('line.focus.line.x')
                                  .attr('clip-path', 'url(#clip)');
        this._focusY = this._focus.select('line.focus.line.y')
                                  .attr('clip-path', 'url(#clip)');
        this._focusTextX = this._focus.select('text.focus.text.x');
        this._focusTextY = this._focus.select('text.focus.text.y');

        this._brushBehaviorX = d3.brushX()
                                 .on('brush', this._brushedX.bind(this._self))
        this._brushBehaviorY = d3.brushY()
                                 .on('brush', this._brushedY.bind(this._self))
        this._brushX = d3.select(this.$.brushX);
        this._brushY = d3.select(this.$.brushY);

        this._info = d3.select(this.$.info);
        this._legend = d3.select(this.$.legend);

        if (this.xScale === 'time') this.$.xbutton.set('icon', 't');
        else this.$.xbutton.set('icon', 'x');

        if (this.yScale === 'time') this.$.ybutton.icon = 't';
        else this.$.ybutton.set('icon', 'y');

        this._svg.selectAll('g,line,text,path,rect')
                 .classed('style-scope', true)
                 .classed('chart-element', true);
        this._sizeLayout();
      },

      _sizeLayout: function() {
        var bRect = this.getBoundingClientRect();

        this._height = Math.max(bRect.height, 150);
        this._width = Math.max(bRect.width, 150);

        this._svg.attr('height', this._height)
                 .attr('width', this._width);

        this._width = this._width - this.margin.left - this.margin.right - this.brushWidth;
        this._height = this._height - this.margin.bottom - this.margin.top - this.brushWidth;

        this._x.range([0, this._width]);
        this._y.range([this._height, 0]);

        this._x2.range([0, this._width]),
        this._y2.range([this._height, 0]);

        this.$.menubutton.style.left = 'auto';
        this.$.menubutton.style.right = this.margin.right + 'px';
        this.$.menubutton.style.top = this.margin.top + 'px';
        this.$.menubutton.style.bottom = 'auto';

        this.$.ybutton.style.left = (this.margin.left - this.brushWidth) + 'px';
        this.$.ybutton.style.right = 'auto';
        this.$.ybutton.style.top = this.margin.top + 'px';
        this.$.ybutton.style.bottom = 'auto';

        this.$.xbutton.style.left = 'auto';
        this.$.xbutton.style.right = this.margin.right + 'px';
        this.$.xbutton.style.top = 'auto';
        this.$.xbutton.style.bottom = (this.margin.bottom - this.brushWidth) + 'px';

        this._chart.attr('transform', 'translate(' + this.margin.left + ',' + (this.brushWidth + this.margin.top) + ')');

        // Limiting Projection to Margin
        this._chart.selectAll('clipPath#clip rect')
                   .attr('width', this._width)
                   .attr('height', this._height);

        this._chart.select('rect.plot')
                  .attr('width', this._width)
                  .attr('height', this._height);

        this._xAxis = this._createAxis(this._x, 'bottom', this.xScale);
        this._yAxis = this._createAxis(this._y, 'left', this.yScale);

        this._xGrid = this._createAxis(this._x, 'bottom', this.xScale, this.gridMult)
                          .tickSize(-this._height, 0, 0)
                          .tickFormat('');
        this._yGrid = this._createAxis(this._y, 'left', this.yScale, this.gridMult)
                          .tickSize(-this._width, 0, 0)
                          .tickFormat('');

        this._chart.select('g.x.axis')
                   .call(this._xAxis)
                   .attr('transform', 'translate(0,' + this._height + ')');
        this._chart.select('g.y.axis')
                   .call(this._yAxis);
        this._chart.select('g.x.grid')
                  .attr('transform', 'translate(0,' + this._height + ')')
                  .call(this._xGrid);
        this._chart.select('g.y.grid')
                  .call(this._yGrid);

        this._focusX.attr('y2', this._height);
        this._focusY.attr('x2', this._width);

        this._brushBehaviorX = d3.brushX()
                                 .handleSize(8)
                                 .extent([[0,0],[this._width,this.brushWidth]])
                                 .on('end', this._brushedX.bind(this._self))
        this._brushAxisX = this._createAxis(this._x2, 'top', this.xScale);
        this._brushX.attr('transform', 'translate(' + this.margin.left + ',' + (this.margin.top + this.brushWidth)+ ')');
        this._brushX.select('rect.background')
                    .attr('width', this._width).attr('height', this.brushWidth)
                    .attr('transform', 'translate(0,-' + this.brushWidth + ')');
        this._brushX.select('g.axis')
                    .call( this._brushAxisX );
        this._brushX.select('g.brush')
                    .attr('transform', 'translate(0,-' + this.brushWidth + ')')
                    .call(this._brushBehaviorX)
                    .on('contextmenu', function() {
                        d3.event.preventDefault();
                        this._clearBrush(this._brushBehaviorX, this._brushX);
                        this._brushedX();
                     }.bind(this._self));

        this._brushBehaviorY = d3.brushY()
                                 .handleSize(8)
                                 .extent([[0,0],[this.brushWidth,this._height]])
                                 .on('end', this._brushedY.bind(this._self));
        this._brushAxisY = this._createAxis(this._y2, 'right', this.yScale);
        this._brushY.attr('transform', 'translate(' + (this.margin.left + this._width) + ',' + (this.margin.top + this.brushWidth) + ')');
        this._brushY.select('rect.background')
                    .attr('width', this.brushWidth).attr('height', this._height)
                    .attr('transform', 'translate(0,0)');
        this._brushY.select('g.axis')
                    .call( this._brushAxisY );
        this._brushY.select('g.brush')
                    .attr('transform', 'translate(0,0)')
                    .call(this._brushBehaviorY)
                    .on('contextmenu', function() {
                        d3.event.preventDefault();
                        this._clearBrush(this._brushBehaviorY, this._brushY);
                        this._brushedY();
                     }.bind(this._self));

        this._info.attr('style', 'left:'+(this.margin.left)+'px; top:'+(this.margin.top+this.brushWidth)+'px');
        this._legend.attr('style', 'right:'+(this.margin.right+this.brushWidth+2)+'px; top:'+(this.margin.top+this.brushWidth+2)+'px');

        this._svg.selectAll('g,line,text,path,rect')
                 .classed('style-scope', true)
                 .classed('chart-element', true);
        this._redraw();
      },

      _createScale: function(option) {
        switch (option) {
          case 'time':
            return d3.scaleTime(); break;
          case 'ln':
            return d3.scaleLog().base(Math.E); break;
          case 'log₁₀':
            return d3.scaleLog(); break;
          case '√':
            return d3.scaleSqrt(); break;
          default:
            return d3.scaleLinear();
        }
      },

      _createAxis: function(scale, orient, kind, tickmult = 1) {
        var axis, ticks, horTicks, verTicks;
        if (this._width < this._height) {
          verTicks = this.ticks;
          horTicks = Math.ceil(this.ticks*this._width/this._height) || this.ticks;
        }
        else {
          horTicks = this.ticks;
          verTicks = Math.ceil(this.ticks*this._height/this._width) || this.ticks;
        }
        switch (orient) {
          case 'top':
            axis = d3.axisTop(); ticks = horTicks; break;
          case 'bottom':
            axis = d3.axisBottom(); ticks = horTicks; break;
          case 'left':
            axis = d3.axisLeft(); ticks = verTicks; break;
          case 'right':
            axis = d3.axisRight(); ticks = verTicks; break;
        }
        axis.scale(scale).ticks(ticks*tickmult);
        if (kind === "time")
          axis.ticks(ticks*tickmult)
              .tickFormat(this.timeFormat.bind(this));
        else if (scale.base && scale.base() === Math.E)
          axis.tickFormat(function(d) { return "ln(y) = " + Math.round(Math.log(d)); })

        return axis;
      },

      timeFormat: function (date) {
        return (d3.timeSecond(date) < date ? this.formatMillisecond
              : d3.timeMinute(date) < date ? this.formatSecond
              : d3.timeHour(date) < date ? this.formatMinute
              : d3.timeDay(date) < date ? this.formatHour
              : d3.timeMonth(date) < date ? (d3.timeWeek(date) < date ? this.formatDay : this.formatWeek)
              : d3.timeYear(date) < date ? this.formatMonth
              : this.formatYear)(date);
      },
      timeFormatRange: function (date, r, pixels) {
        var msProPixel = (r[1] - r[0]).valueOf()/pixels;
        return (msProPixel < 500 ? this.formatMillisecond
              : msProPixel < 5000 ? this.formatSecond
              : msProPixel < 60000 ? this.formatMinute
              : msProPixel < 3600000 ? this.formatHour
              : msProPixel < 86400000  ? this.formatDay
              : msProPixel < 604800000 ? this.formatWeek
              : msProPixel < 2419200000 ? this.formatMonth
              : this.formatYear)(date);
      },

      redraw: function () {
        this.debounce('redraw', function() { this._redraw() }, 15);
      },

      _redraw: function () {
        this._setAllDomains();

        if (this._elements.length > 0)
          this._elements.forEach(function(g) { g.redraw(); });

        this._chart.select('g.x.axis').transition(50).call(this._xAxis);
        this._chart.select('g.y.axis').transition(50).call(this._yAxis);
        this._chart.select('g.x.grid').transition(50).call(this._xGrid);
        this._chart.select('g.y.grid').transition(50).call(this._yGrid);

        this._brushX.select('g.axis').transition(50).call(this._brushAxisX);
        this._brushY.select('g.axis').transition(50).call(this._brushAxisY);

        this._svg.selectAll('g,line,text,path,rect')
                 .classed('style-scope', true)
                 .classed('chart-element', true);
        this._updateFocusText();
      },

      _brushedX: function() {
        if (d3.event.selection) {
          var domain;
          if (this._width - d3.event.selection[1] < this.clampExtend) {
            if (this._isClamping === false) {
              this._isClamping = true;
              this._brushX.select('rect.selection').classed('clamp', true);
              this._brushBehaviorX.move( this._brushX.select('g.brush'), [d3.event.selection[0], this._width]);
            }
            domain = [ this._x2.invert(d3.event.selection[0]),
                       this._x2.invert(this._width) ];
          }
          else {
            this._isClamping = false;
            this._brushX.select('rect.selection').classed('clamp', false);
            domain = [ this._x2.invert(d3.event.selection[0]),
                       this._x2.invert(d3.event.selection[1]) ];
          }
          if (domain[0] > domain[1])
            domain.reverse();
          this._x.domain(domain);
        }
        else {
          this._isClamping = false;
          this._brushX.select('rect.selection').classed('clamp', false);
          this._x.domain(this._x2.domain());
        }
        this._elements.forEach(function(g) { g.redraw(); });
        this._chart.select('g.x.axis').transition(50).call(this._xAxis);
        this._chart.select('g.x.grid').transition(50).call(this._xGrid);
        this._brushX.select('g.axis').transition(50).call(this._brushAxisX);
        this._svg.selectAll('g,line,text,path,rect')
                 .classed('style-scope', true)
                 .classed('chart-element', true);
      },
      _brushedY: function() {
        if (d3.event.selection) {
          var domain = [ this._y2.invert(d3.event.selection[0]),
                         this._y2.invert(d3.event.selection[1]) ];
          if (domain[0] > domain[1])
            domain.reverse();
          this._y.domain(domain);
        }
        else
          this._y.domain(this._y2.domain());
        this._elements.forEach(function(g) { g.redraw(); });
        this._chart.select('g.y.axis').transition(50).call(this._yAxis);
        this._chart.select('g.y.grid').transition(50).call(this._yGrid);
        this._brushY.select('g.axis').transition(50).call(this._brushAxisY);
        this._svg.selectAll('g,line,text,path,rect')
                 .classed('style-scope', true)
                 .classed('chart-element', true);
      },

      _clearBrush: function(behavior, selection) {
        behavior.move(selection.select('g.brush'),[0,0]);
      },
      _brushMoveX: function(extent) {
        if (Array.isArray(extent) === false) return;
        this._brushBehaviorX.move(
          this._brushX.select('g.brush'),
          [this._x2(extent[0]),this._x2(extent[1])]);
      },
      _brushMoveY: function(extent) {
        if (Array.isArray(extent) === false) return;
        var domain = [this._y2(extent[1]),this._y2(extent[0])];
        this._brushBehaviorY.move(this._brushY.select('g.brush'), domain);
      },
      _brushIsEmpty: function(selection) {
        var domain = d3.brushSelection(selection.select('g.brush').node());
        if (domain === null) return undefined;
        else if (Math.abs(domain[1]-domain[0]) < 1) return true;
        else return false;
      },
      _brushDomain: function(selection, scale) {
        var domain = d3.brushSelection(selection.select('g.brush').node());
        if (domain === null) return undefined;
        domain = [scale.invert(domain[0]), scale.invert(domain[1])];
        if (domain[0] > domain[1])
          domain.reverse();
        return domain;
      },

      setAllDomains: function () {
        this.debounce('domains', function() { this._setAllDomains() }, 100);
      },

      _setAllDomains: function () {
        if (this._elements.length === 0) return;

        var graphs = this._elements;
        var domainX, domainY = [0, 0], domainBrushX, domainBrushY, v;

        domainBrushX = this._brushDomain(this._brushX, this._x2);
        domainBrushY = this._brushDomain(this._brushY, this._y2);
        domainX = [ d3.min(graphs,function(g){ return g._rangeX[0] }) ,
                    d3.max(graphs,function(g){ return g._rangeX[1] }) ];
        domainY = [ d3.min(graphs,function(g){ return g._rangeY[0] }) ,
                    d3.max(graphs,function(g){ return g._rangeY[1] }) ];

        // rounding y-domains to the according decimal exponent
        if (domainY[0] !== undefined) {
          v = (domainY[0]).toExponential().split('e');
          domainY[0] = (Math.floor(v[0])) * Math.pow(10,parseInt(v[1],10));
        }
        if (domainY[1] !== undefined) {
          v = (domainY[1]).toExponential().split('e');
          domainY[1] = (Math.ceil(v[0]) + 1) * Math.pow(10,parseInt(v[1],10));
        }

        this._x2.domain(domainX);
        this._y2.domain(domainY);

        if (domainBrushX !== undefined) {
          if ( domainBrushX[0] <= domainX[0] ) {
            if (this._isClamping === true || domainBrushX[1] <= domainX[0]) {
              this._clearBrush(this._brushBehaviorX, this._brushX);
              domainBrushX = domainX;
            }
            else {
              domainBrushX = [domainX[0], domainBrushX[1]];
              this._brushMoveX( domainBrushX );
            }
          }
          else if (this._isClamping === true) {
            domainBrushX = [domainBrushX[0], domainX[1]];
            this._brushMoveX( domainBrushX );
          }
          else {
            this._brushMoveX( domainBrushX );
          }
          domainX = domainBrushX;
        }
        if (domainBrushY !== undefined) {
          this._brushMoveY( domainBrushY );
          domainY = domainBrushY;
        }
        this._x.domain(domainX);
        this._y.domain(domainY);
      },

      _showFocus: function() {
        d3.select('g#focus').style('opacity', 1);
        this._focus.__shown = true;
      },
      _updateFocus: function() {
        if (!this._focus.__shown) return;
        var box = this._chart.node().getBBox();
        var x = -box.width + this._width + d3.event.layerX;
        var y = -box.height + this._height + d3.event.layerY;
        this._focusX.attr('transform', 'translate(' + x + ',0)');
        this._focusTextX.attr('transform', 'translate(' + (x + 4) + ',' + (this._height - 8) + ')');
        this._focusY.attr('transform', 'translate(0,' + (y) + ')');
        this._focusTextY.attr('transform', 'translate(0,' + (y - 4) + ')');
        this._focus.__mouse = {x: x, y: y};
        this._updateFocusText();
      },
      _updateFocusText: function() {
        if (!this._focus.__shown) return;
        var x = this._x.invert(this._focus.__mouse.x),
            y = this._y.invert(this._focus.__mouse.y),
            dy = this._y.domain(),
            p = d3.precisionFixed((dy[1]-dy[0])/100/this.ticks),
            fn = d3.format("." + p + "f");
        this._focusTextX.text(this.timeFormatRange.call(this, x, this._x.domain(), this._width));
        this._focusTextY.text(fn(y));
      },
      _hideFocus: function() {
        d3.select('g#focus').transition(1000).style('opacity', 0);
        this._focus.__shown = false;
      },
      _updateInfo: function(d) {
        this.$.info.removeAttribute('hidden');
        var dy = this._y.domain(),
            p = d3.precisionFixed((dy[1]-dy[0])/100/this.ticks),
            y = d3.format("." + p + "f")(d.y),
            x = this.timeFormatRange.call(this, d.x, this._x.domain(), this._width);
        this.$.infoX.innerText = 'x = ' + x;
        this.$.infoY.innerText = 'y = ' + y;
        setTimeout((function(){ this.setAttribute('hidden', true) }).bind(this.$.info) , 10000);
      },
      _toggleInfo: function() {
        if (this.$.info.hasAttribute('hidden')) {
          this.$.info.removeAttribute('hidden');
        }
        else {
          this.$.info.setAttribute('hidden', true);
        }
      },
      toggleMenu: function() {
        if (this.$.menu.hasAttribute('hidden')) {
          this.$.menu.removeAttribute('hidden');
        }
        else {
          this.$.menu.setAttribute('hidden', true);
        }
      },
      changeInterpolation: function(interpolation, oldValue) {
        if (this._elements === undefined) return;
        this._elements.forEach(
          function(g) {
            g.interpolation = interpolation;
          });
      },
      changeScale: function(newValue, oldValue) {
        if (oldValue === undefined) return;
        this._buildLayout();
        this._sizeLayout();
        this.redraw();
      },
      changeDots: function(e) {
        if (this._elements === undefined) return;
        this._elements.forEach(
          function(g) {
            g.set('noDots', !e.target.checked)
          });
      },
      changeLines: function(e) {
        if (this._elements === undefined) return;
        this._elements.forEach(
          function(g) {
            g.set('noLine', !e.target.checked)
          });
      },
      changeAreas: function(e) {
        if (this._elements === undefined) return;
        this._elements.forEach(
          function(g) {
            g.set('noFill', !e.target.checked)
          });
      }
    });

  </script>

</dom-module>

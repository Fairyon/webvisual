<script>
  ElementBehavior = {

    properties: {
        label: {
          type: String,
          value: "",
          reflectToAttribute: true
        },
        id: {
          type: String,
          value: "",
          reflectToAttribute: true
        },
        keys: {
          type: Object,
          value: function() { return {}; },
          reflectToAttribute: true
        },
        values: {
          type: Array,
          value: function() { return []; }
        },
        firstExceeds: {
          type: Array,
          value: function() { return []; }
        },
        lastExceeds: {
          type: Array,
          value: function() { return []; }
        },
        isBoolean: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        updatable: {
          type: Boolean,
          value: true,
          readOnly: true,
          reflectToAttribute: true
        },
        isExceeding: {
          type: Boolean,
          value: false
        },
        captionKeys: {
          type: Array,
          value: function() { return []; },
          reflectToAttribute: true
        },
        captionStyle: {
          type: Array,
          value: function() {
            return [
              'font-weight: bold; font-size: 1em;',
              'font-weight: normal; font-size: 0.85em;',
              'font-weight: normal; font-size: 0.75em;',
              'font-weight: normal; font-size: 0.6em;'
            ];
          }
        }
    },

    getKey: function(key) {
      // if(this.element && this.element[key])
        return this.keys[key];
    },
    computeX: function(change, index){
      if (change.base && change.base.length != 0){
        var date = this.get('x', change.base[index]);
        if(date){
          return new Date(date).toLocaleTimeString();
        }
        else
          return ' ';
      }
    },
    computeY: function(change, index){
      if (change.base && change.base.length != 0){
        if (this.isBoolean){
          var exceeds = this.get('exceeds', change.base[index]);
          if (exceeds==true || exceeds==false)
            return '✗';
          else
            return '✓';
        }
        else {
          var value = this.get('y', change.base[index]);
          if ((value !== undefined) && (value !== ''))
            return value;
          else
            return ' ';
        }
      }
      else
        return ' ';
    },
    unshiftValues: function(value) {
      this.unshift('values', value);

      if (value.exceeds === null) {
        if(this.isExceeding !== false) {
          this.setExceedingState(false);
          this.push("lastExceeds", this.values[1]);
        }
      }
      else if (value.exceeds === true || value.exceeds === false) {
        if(this.isExceeding === false) {
          this.setExceedingState(true);
          this.push("firstExceeds", this.values[0]);
        }
      }
      this._updateView(value);
    },

    spliceValues: function(start, end) {
      this.splice('values', start, end);
    },

    setExceedingState: function(state) {
      this.set('isExceeding', state);
    },

    _updateView: function() {
    }

    // TODO: eventuell durch vorhandene obere Funktionen zu lösen
    // selector: name of the predicted element's values
    // e.g.: 'lastExceeds', 'firstExceeds'
  };
</script>

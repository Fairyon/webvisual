<script>
  PageBehavior = {
    properties: {
      data: {
        type: Array,
        value: function() { return []; },
        notify: true
      },
      selectedElement: {
        type: Object,
        value: function() { return {}; }
      },
      paths: {
        type: Object,
        value: function() { return {}; }
      },
      labels: {
        type: Array,
        value: function() { return []; }
      },
      indexOfLabel: {
        type: Object,
        value: function() { return {}; }
      },
      groupingKeys: {
        type: Object,
        value: function() { return {}; }
      },
      preferedGroupingKeys: {
        type: Object,
        value: function() { return {}; },
        notify: true
      },
      // selected Label
      selectedLabel: {
        type: String,
        observer: "_selectedLabelChanged"
      },
      groupBy: {
        type: String,
        observer: "_setPreferedGroupingKey"
      },
      maxTotalLines: {
        type: Number
      },
      interval: {
        type: Number
      }
    },
    _computeSelectedLabelId: function(label) {
      if (label == undefined)
        return this.indexOfLabel[this.labels[0]];
      else
        return this.indexOfLabel[label];
    },
    _selectedLabelChanged: function(newValue, oldValue) {
      this.set('groupBy', this.preferedGroupingKeys[this.selectedLabel]);
      this.$.labeltemplate.render();

      if(this.opened) {
        this.deselectElement();
      }
    },
    _setPreferedGroupingKey: function(newValue, oldValue) {
      var label = this.selectedLabel;
      this.set('preferedGroupingKeys.' + label, newValue);
      if (oldValue) {
        self = this;
        this.async(function(){
          // Swaping Elements Data to the new groupBy
          var newItem, oldItem, newPath, oldPath, tmp;
          for (var id in self.paths[label][oldValue]) {
            newPath = self.paths[label][newValue][id];
            oldPath = self.paths[label][oldValue][id];
            newItem = self.get(newPath);
            oldItem = self.get(oldPath);
            tmp = self.splice(newPath,0,newItem.length - 1);
            self.set(newPath, self.splice(oldPath,0,oldItem.length - 1));
            self.set(oldPath, tmp);
          }
        });
      }

      // if (this.$$('template#grouptemplate'))
      //   this.$$('template#grouptemplate').render();

      // var selectedLabelId = this._computeSelectedLabelId(this.selectedLabel);
      // if(groupBy && this.groupBy in this.groups[selectedLabelId]) {
      //   this.set("groupBy",groupBy);
      //   this.set("preferedGroupingKeys.#"+selectedLabelId, groupBy);
      // }
      // else if (this.preferedGroupingKeys && this.preferedGroupingKeys[selectedLabelId] && this.preferedGroupingKeys[selectedLabelId] in this.groups[selectedLabelId])
      //   this.set("groupBy",this.preferedGroupingKeys[selectedLabelId]);
      // else
      //   this.set("groupBy","all");
    },
    _moveData: function(toGroupBy, fromGroupBy) {


      // self = this;
      // this.async( function() {
      //   var label = self.labels[self.selectedLabel];
      //   var labelindex = self.indexOfLabel[label];
      //   var a, b;
      //   for (a = 0; a < this.data[labelindex].groups.length; a++) {
      //     if(this.data[labelindex].groups[a].key == this.preferedGroupingKeys[label])
      //       break;
      //   }
      //   for (b = 0; b < this.data[labelindex].groups[a].subgroup.length; b++) {
      //     c = this.data[labelindex].groups[a].subgroup[b].ids.indexOf(id);
      //     if(c !== -1)
      //       break;
      //   }
      // });
    },
    // TODO: move Captions into Sign-Element etc.
    getGroupingKeys: function(label) {
      if (this.groupingKeys)
        return this.groupingKeys[label];
    },
    getElementsKey: function(element,key) {
      if(element && element[key])
        return element[key];
    },
    sortGroup: function(first,next){
      if (first.ids.length > next.ids.length)
        return true;
      else
        return false;
    },
    // filter data to selected ids
    filterSelectedLabel: function(dataItem) {
      return (this.selectedLabel === dataItem.label);
    },
    filterPreferedGroup: function(groupItem) {
      return (this.preferedGroupingKeys[this.selectedLabel] === groupItem.key);
    },
    _removeAllExceedingElements: function(all) {
      // @all - if false, only elements will be removed,
      //        if there are not of the selected Labels from select-page
      if (all != false)
        all = true;

      var items = Polymer.Collection.get(this.exceeding).getItems();
      for (var i=0; i < items.length; i++) {
        if (all || this.labels.indexOf(items[i].label) == -1) {
          var key = Polymer.Collection.get(this.exceeding).getKey(items[i]);
          if(key) {
            this.unlinkPaths('exceeding.' + key);
            this.arrayDelete('exceeding', items[i]);
          }
        }
        if (this.exceeding.length == 0)
          this.set("isExceeding",false);
      }
    }
  };
</script>

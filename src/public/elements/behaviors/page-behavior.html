<script>
  PageBehavior = {
    properties: {
      data: {
        type: Array,
        value: function() { return []; }
      },
      selectedElement: {
        type: Object,
        value: function() { return {}; }
      },
      labels: {
        type: Array,
        value: function() { return []; }
      },
      labelIndex: {
        type: Object,
        value: function() { return {}; }
      },
      groupingKeys: {
        type: Object,
        value: function() { return {}; }
      },
      preferedGroupingKeys: {
        type: Object,
        value: function() { return {}; },
      },
      // selected Label (Tab index)
      // important note: there is a difference with selected LabelIndex because of initial selection order
      selectedLabel: {
        type: Number,
        notify: true,
        observer: "_selectedLabelChanged"
      },
      groupBy: {
        type: String,
        value: "all",
        observer: "_setPreferedGroupingKey"
      },
      maxTotalLines: {
        type: Number
      },
      interval: {
        type: Number
      }
    },
    // observers: [
    //   "_labelsChanged(labels.length)"
    // ],
    // _labelsChanged: function(length) {
    //   // if(length > 0) {
    //     // this.set("selectedLabel",0);
    //     // this._selectedLabelChanged();
    //     // this._removeAllExceedingElements(false);
    //   // }
    // },
    _computeSelectedLabelId: function(index) {
      if (index == undefined || this.labels == undefined)
        return 0;
      else
        return this.labelIndex[this.labels[index]];
    },
    _selectedLabelChanged: function(newv, old) {
      var selectedLabelId = this._computeSelectedLabelId(this.selectedLabel);
      this.set('groupBy', this.preferedGroupingKeys[selectedLabelId]);
      // this.setSelectedGroup();
      this.$.labeltemplate.render();
      // var templ = this.$$('template#'+this.labels[this.selectedLabel]+'.grouptemplate');
      // if (templ)
      //   templ.render();
      if(this.opened) {
        this.deselectElement();
      }
    },
    _setPreferedGroupingKey: function(groupBy, oldValue) {
      // var selectedLabelId = this._computeSelectedLabelId(this.selectedLabel);
      // if(groupBy && this.groupBy in this.groups[selectedLabelId]) {
      //   this.set("groupBy",groupBy);
      //   this.set("preferedGroupingKeys.#"+selectedLabelId, groupBy);
      // }
      // else if (this.preferedGroupingKeys && this.preferedGroupingKeys[selectedLabelId] && this.preferedGroupingKeys[selectedLabelId] in this.groups[selectedLabelId])
      //   this.set("groupBy",this.preferedGroupingKeys[selectedLabelId]);
      // else
      //   this.set("groupBy","all");
    },
    // TODO: move Captions into Sign-Element etc.
    getGroupingKeys: function(change, index) {
      return this.groupingKeys[this.labels[index]];
    },
    getElementsKey: function(element,key) {
      if(element && element[key])
        return element[key];
    },
    sortGroup: function(first,next){
      if (first.ids.length > next.ids.length)
        return true;
      else
        return false;
    },
    // filter data to selected ids
    filterSelectedLabel: function(dataItem) {
      return (this.labels[this.selectedLabel] === dataItem.label);
    },
    filterPreferedGroup: function(groupItem) {
      return (this.preferedGroupingKeys[this.labels[this.selectedLabel]] === groupItem.key);
    },
    _removeAllExceedingElements: function(all) {
      // @all - if false, only elements will be removed,
      //        if there are not of the selected Labels from select-page
      if (all != false)
        all = true;

      var items = Polymer.Collection.get(this.exceeding).getItems();
      for (var i=0; i < items.length; i++) {
        if (all || this.labels.indexOf(items[i].labelname) == -1) {
          var key = Polymer.Collection.get(this.exceeding).getKey(items[i]);
          if(key) {
            this.unlinkPaths('exceeding.' + key);
            this.arrayDelete('exceeding', items[i]);
          }
        }
        if (this.exceeding.length == 0)
          this.set("isExceeding",false);
      }
    }
  };
</script>

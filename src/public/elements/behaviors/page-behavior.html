<script>
  PageBehavior = {
    properties: {
      data: {
        type: Array,
        value: function() { return []; }
      },
      selectedElement: {
        type: Object,
        value: function() { return {}; }
      },
      selectedGroup: {
        type: Array,
        value: function() { return []; }
      },
      ids: {
        type: Array,
        value: function() { return []; }
      },
      labels: {
        type: Array,
        value: function() { return []; }
      },
      availableLabels: {
        type: Array,
        value: function() { return []; }
      },
      groupingKeys: {
        type: Array,
        value: function() { return []; }
      },
      groups: {
        type: Array,
        value: function() { return []; }
      },
      preferedGroupingKeys: {
        type: Array,
        value: function() { return []; }
      },
      // selected Label (Tab index)
      // important note: there is a difference with selected LabelIndex because of initial selection order
      selectedLabel: {
        type: Number,
        value: 0,
        notify: true,
        observer: "_selectedLabelChanged"
      },
      groupBy: {
        type: String,
        value: "all",
        observer: "setSelectedGroup"
      },
      maxTotalLines: {
        type: Number
      },
      interval: {
        type: Number
      }
    },
    observers: [
      "_labelsChanged(labels.length)"
    ],
    _labelsChanged: function(length) {
      if(length > 0) {
        this.set("selectedLabel",0);
        this._selectedLabelChanged();
        this._removeAllExceedingElements(false);
      }
    },
    _computeSelectedLabelId: function(selectedLabel) {
      if (selectedLabel == undefined || this.labels == undefined || this.availableLabels == undefined)
        return 0;
      else
        return this.availableLabels.indexOf(this.labels[selectedLabel]);
    },
    _selectedLabelChanged: function() {
      var selectedLabelId = this._computeSelectedLabelId(this.selectedLabel);
      this.setGroupBy(this.preferedGroupingKeys[selectedLabelId]);
      this.setSelectedGroup();
      this.$.maintemplate.render();
      if(this.opened) {
        this.deselectElement();
      }
    },
    groupElements: function(item,group){
      if (group.name == "all")
        return true;
      else if (group.ids && group.ids.indexOf(item.id) != -1)
        return true;
      else
        return false;
    },
    setSelectedElement: function(e) {
    },
    deselectedElement: function(e) {
    },
    setGroupBy: function(groupBy) {
      var selectedLabelId = this._computeSelectedLabelId(this.selectedLabel);
      if(groupBy && this.groupBy in this.groups[selectedLabelId]) {
        this.set("groupBy",groupBy);
        this.set("preferedGroupingKeys.#"+selectedLabelId, groupBy);
      }
      else if (this.preferedGroupingKeys && this.preferedGroupingKeys[selectedLabelId] && this.preferedGroupingKeys[selectedLabelId] in this.groups[selectedLabelId])
        this.set("groupBy",this.preferedGroupingKeys[selectedLabelId]);
      else
        this.set("groupBy","all");
    },
    setSelectedGroup: function(){
      var selectedLabelId = this._computeSelectedLabelId(this.selectedLabel);
      if(this.groups && this.groupBy && this.groups[selectedLabelId]){
        this.set("selectedGroup", this.groups[selectedLabelId][this.groupBy]);
        this.linkPaths("selectedGroup", "groups." + selectedLabelId + "." + this.groupBy);
      }
    },
    sortGroup: function(first,next){
      if (first.ids.length > next.ids.length)
        return true;
      else
        return false;
    },
    // filter data to selected ids
    filterSelectedLabel: function(dataItem) {
      return (this._computeSelectedLabelId(this.selectedLabel) === this.data.indexOf(dataItem));
    },
    filterLabel: function(dataItem,selectedlabel) {
      return (this._computeSelectedLabelId(selectedLabel) === this.data.indexOf(dataItem));
    },
    _removeAllExceedingElements: function(all) {
      if (all != false)
        all = true;

      var items = Polymer.Collection.get(this.exceeding).getItems();
      for (item of items) {
        if (all || this.labels.indexOf(item.labelname) == -1) {
          var key = Polymer.Collection.get(this.exceeding).getKey(item);
          if(key) {
            this.arrayDelete('exceeding', item);
            this.unlinkPaths('exceeding.' + key);
          }
        }
        if (this.exceeding.length == 0)
          this.set("isExceeding",false);
      }
    }
  };
</script>

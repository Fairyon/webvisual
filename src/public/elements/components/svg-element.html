<!--
`svg-element` provides rendering a svg in a container.

#the svg has to have following specifications:
- all tranistions of the included paths must be relative
- there doesn't have to be a ''matrix'' transformation on the top element (very important), else zoom transitions won't work correctly
- 'view-box'-attribute has to be set
- the to top element of the svg has to be a plain g-element (look up grouping in svg) with no transformations on it

#how to achive this in Inkscape:
> 1. Double click the group in Inkscape, to enter it.
> 2. Select all the contents of the group by pressing Ctrl+A, and copy them with Ctrl+C.
> 3. Double click outside the group to leave the group.
> 4. Edit > Paste In Place (Ctrl+Alt+V) â€“ at this point, group transformations are applied to the obects you paste.
> 5. Group the objects again (Ctrl+G)
> 6. Move the new group to the same depth as the original, and delete the original group. (This is probably easier with the XML editor, Ctrl+Shift+X.)
<http://stackoverflow.com/a/22629215/5077914>

#about absolut positioning
<http://stackoverflow.com/a/26053262>

Use `isZoomable` to make it isZoomable.

#reference and inspiration
<http://bl.ocks.org/mbostock/9656675>

@element svg-element
-->

<!-- <script src='../../../components/d3/d3.min.js'></script> -->

<dom-module id="svg-element">

<style>
  :host {
    border-radius: inherit;
    font-family: Fira Sans Light;
    font-weight: normal;
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
    -webkit-touch-callout: none; -webkit-tap-highlight-color:rgba(0,0,0,0);
    color: rgb(255, 237, 168);

    display: block;
    min-height: 1px;
  	position: relative;
  	overflow: hidden;
  }
  div#svgContainer {
    border-radius: inherit;
    display: block;
  }
  .text {
    fill: currentColor !important;
    font-family: inherit !important;
    font-weight: inherit !important;
    letter-spacing: normal !important;
  }
  .selectable {
    /*fill: rgb(203, 67, 107) !important;
    stroke: white !important;
    stroke-linecap: round;
    stroke-linejoin: round;*/
  }
  .clicked {
    fill: orange !important;
  }
  .selected {
    /*fill: #E72626 !important;*/
    z-index: 10;
    box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
    animation-name: selected-animation;
    animation-duration: 4s;
    animation-timing-function: ease-in-out;
    animation-iteration-count: infinite;
    transform-origin: center;
  }
  @keyframes selected-animation {
    0%   {transform: scale(1);}
    33%  {transform: scale(0.5);}
    100% {transform: scale(1);}
  }
</style>
<template>
  <div id="svgContainer">
  </div>
</template>

<script>
  SVGElement = Polymer({
    is: 'svg-element',

    properties: {
      src: {
        type: String,
        value: '',
        observer: "_sourceChanged"
      },
      selectable: {
        type: String,
        value: 'path,rect,circle,ellipse,polyline,polygon,line',
        observer: "_selectableChanged"
      },
      selected: {
        type: String,
        observer: "_selectedChanged"
      },
      selectedItems: {
        type: Array,
        value: function() { return []; }
      },
      classAttr: {
        type: String,
        value: "selected"
      },
      multi: {
        type: Boolean,
        value: true
      },
      isZoomable: {
        type: Boolean,
        value: true,
        observer: "_isZoomableChanged"
      },
      minZoom: {
        type: Number,
        value: 1,
        observer: "_isZoomableChanged"
      },
      maxZoom: {
        type: Number,
        value: 6,
        observer: "_isZoomableChanged"
      },
      zoomPartition: {
        type: Number,
        value: 2
      },
      height: {
        type: Number
      },
      width: {
        type: Number
      },
      mainG: {
        type: Object
      },
      svgContainer: {
        type: Object
      },
      _d3Zoom: {
        type: Function
      }
    },

    attached: function() {
    },

    _sourceChanged: function(source) {
      if (source) {
        if (!this.$.svgContainer) {
          var div = document.createElement('div');
          div.setAttribute("id", "svgContainer");
          Polymer.dom(this.root).appendChild(div);
          Polymer.dom.flush();
        }
        if (this.$.svgContainer.firstChild) {
          while (this.$.svgContainer.firstChild) {
            this.$.svgContainer.removeChild(this.$.svgContainer.firstChild);
          }
          Polymer.dom.flush();
        }

        this.svgContainer = d3.select(this.$$('div#svgContainer'));

        // import svg
        var self = this;
        d3.xml(source, "image/svg+xml",
          function(error, xml) {
            if (error) throw error;
            // import svg to document
            var svgNode = document.importNode(xml.documentElement, true);

            // register zoom function
            self._d3Zoom = d3.behavior.zoom()
                             .scaleExtent([self.minZoom, self.maxZoom])
                             .on("zoom", self._zoom);

            // append imported svg to this element
            self.svgContainer.node().appendChild(svgNode);

            // set style for resizing
            d3.select(svgNode).attr("style", "display: block;")
                              .attr("preserveAspectRatio", "xMinYMin meet")
                              .attr("width", "100%")
                              .attr("height", null)
                              .call(self._d3Zoom);

            self.mainG = self.svgContainer.select("g")
                                          .attr("id", "mainG");
            self.mainG.selectAll("text")
                      .classed("text", true)  // for styling text
                      .classed("svg-element", true); // style-scoping in polymer

            // get dimensions
            var viewBox = d3.select(svgNode)
                            .attr("viewBox")
                            .split(' ');
            self.width  = viewBox[2] - viewBox[0];
            self.height = viewBox[3] - viewBox[1];

            // set selectable elements
            self._selectableChanged();

            self.selected = "ellipse";
          });
      }
    },
    _zoom: function () {
      d3.select(this).select("g#mainG")
                     .transition()
                     .duration(100)
                     .ease("linear")
                     .attr("transform", "translate(" + d3.event.translate + ") scale(" + d3.event.scale + ")");
    },

    _zoomToElement: function(elem, classAttr) {
      if (!elem) return;

      // calc centered zoom coordinates
      var transform = this._calcCenterZoom(elem);

      // call zoom to translate and scale
      this.svgContainer.select("svg")
                       .transition()
                       .duration(500)
                       .call(this._d3Zoom.translate(transform.translate).scale(transform.scale).event);
    },

    _zoomToPosition: function(e, f) {
    },

    _calcCenterZoom: function(elem) {
      if (!elem) return;
      // calculate scale based on partioned view and dimensions of the element
      var bboxG = this.mainG.node().getBBox();
      var boundG = this.mainG.node().getBoundingClientRect();

      var boundE;
      if (elem.nodeType)
        boundE = elem.getBoundingClientRect();
      else
        boundE = elem;

      // absolute position (for angled or transioned element)
      var os = bboxG.width/boundG.width;
      var x = (boundE.left - boundG.left)*os + bboxG.x;
      var y = (boundE.top - boundG.top)*os + bboxG.y;

      // calculate zoom based on partions or minZoom or maxZoom
      var scale = Math.min(this.width/(this.zoomPartition*os*boundE.width), this.height/(this.zoomPartition*os*boundE.height));

      if (scale < this.minZoom)
        scale = this.minZoom;
      if (scale > this.maxZoom)
        scale = this.maxZoom;

      // center view
      x = -scale*(x) + (this.width - scale*boundE.width*os)/2;
      y = -scale*(y) + (this.height - scale*boundE.height*os)/2;

      if (isNaN(x) || isNaN(y) || isNaN(scale))
        return {translate: [0,0], scale: 1};
      else
        return {translate: [x,y], scale: scale};
    },

    _selectedChanged: function(selector) {

      var boundE, bounds = [];
      self = this;
      this.svgContainer.selectAll(selector)
                       .each(
                         function() {
                           boundE = this.getBoundingClientRect();
                           bounds[0] = (bounds[0] > boundE.left ? boundE.left : bounds[0]) || boundE.left;
                           bounds[1] = (bounds[1] > boundE.top ? boundE.top : bounds[1]) || boundE.top;
                           bounds[2] = (bounds[2] < boundE.right ? boundE.right : bounds[2]) || boundE.right;
                           bounds[3] = (bounds[3] < boundE.bottom ? boundE.bottom : bounds[3]) || boundE.bottom;
                           self._select(this, self.classAttr, self.multi)
                         });

      boundE = { left: bounds[0],
                 top: bounds[1],
                 height: bounds[3] - bounds[1],
                 width: bounds[2] - bounds[0] };

      this._zoomToElement(boundE, self.classAttr);
    },

    _select: function(elem, classAttr, multi, toggle) {
      var pos = this.selectedItems.indexOf(elem);
      if (multi) {
        if ( pos == -1 )
          this.push("selectedItems", d3.select(elem).classed(classAttr, true).node());
        else if (toggle){
          d3.select(this.selectedItems[pos]).classed(classAttr, false);
          this.arrayDelete('selectedItems', elem);
        }
      } else {
        for (var i in this.selectedItems) {
          if (this.selectedItems[i].classList.contains(classAttr)) {
            d3.select(this.selectedItems[i]).classed(classAttr, false);
            this.arrayDelete('selectedItems', this.selectedItems[i]);
          }
        }
        if (pos == -1 || !toggle) {
          this.push("selectedItems", d3.select(elem).classed(classAttr, true).node());
        }
      }
    },

    _selectableChanged: function() {
      if (this.mainG) { // if svg is loaded
        // previous selectable elements: remove 'selectable' class and click listener
        this.mainG.selectAll(".selectable")
                  .classed("selectable", false)
                  .on("click", null);

        // add 'selectable' class and click listener
        self = this;
        this.mainG.attr("id","mainG")
                  .selectAll(this.selectable)
                  .classed("selectable", true)  // for styling selectable
                  .classed("svg-element", true) // for style-scoping in polymer
                  .on("click",
                    function() {
                      self._zoomToElement(this);
                      self._select(this, "clicked", false, true);
                    });
      }
    },

    _resetZoom: function() {
      // deselect selectedItem
      if (this.selectedItem) {
        this.selectedItem.classed("selectedItem", false);
        this.selectedItem = d3.select(null);
      }
      // transition to (0,0) scale 1
      this.svgContainer.transition()
                       .duration(750)
                       .call(this._d3Zoom.translate([0, 0]).scale(1).event);
    },

    _isZoomableChanged: function() {
      if (this.svgContainer) {
        if (!this.isZoomable) {
          this._resetZoom()
          this._d3Zoom.on("zoom", null);
        }
        else {
          this._d3Zoom = d3.behavior.zoom()
                                    .scaleExtent([this.minZoom, this.maxZoom])
                                    .on("zoom", this._zoom);
          this.svgContainer.select("svg")
                           .call(this._d3Zoom);
        }
      }
    }
  });
</script>

<dom-module>

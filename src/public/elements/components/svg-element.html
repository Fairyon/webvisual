<!--
`svg-element` provides rendering a svg in a container.

#the svg has to have following specifications:
- all tranistions of the included paths must be relative
- there doesn't have to be a ''matrix'' transformation on the top element (very important), else zoom transitions won't work corviewly
- 'view-box'-attribute has to be set
- the to top element of the svg has to be a plain g-element (look up grouping in svg) with no transformations on it

#how to achive this in Inkscape:
> 1. Double click the group in Inkscape, to enter it.
> 2. Select all the contents of the group by pressing Ctrl+A, and copy them with Ctrl+C.
> 3. Double click outside the group to leave the group.
> 4. Edit > Paste In Place (Ctrl+Alt+V) â€“ at this point, group transformations are applied to the obects you paste.
> 5. Group the objects again (Ctrl+G)
> 6. Move the new group to the same depth as the original, and delete the original group. (This is probably easier with the XML editor, Ctrl+Shift+X.)
<http://stackoverflow.com/a/22629215/5077914>

#about absolut positioning
<http://stackoverflow.com/a/26053262>

Use `isZoomable` to make it isZoomable.

#reference and inspiration
<http://bl.ocks.org/mbostock/9656675>

@element svg-element
-->

<!-- <script src='../../../components/d3/d3.min.js'></script> -->

<dom-module id="svg-element">

<style>
  :host {
    border-radius: inherit;
    font-family: Fira Sans Light;
    font-weight: normal;
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
    -webkit-touch-callout: none; -webkit-tap-highlight-color:rgba(0,0,0,0);
    color: #1f1f1f;
    flex: 1;
    display: flex;
    width: auto;
    height: auto;
  	position: relative;
  	overflow: hidden;
  }
  svg#main {
    flex: 1;
    height: auto;
  }
  div#svgContainer {
    border-radius: inherit;
    display: flex;
    width: 100%;
    height: auto;
  }
  div#control {
    position: absolute;
    padding-top: 12px;
    padding-bottom: 12px;
    padding-right: 6px;
    bottom: 0;
    right: 0;
  }
  div#control[top] {
    top: 0;
    right: 0;
    bottom: auto;
  }
  paper-icon-button {
    margin-right: 6px;
    transition: none;
    color: var(--icon-color, rgb(120, 120, 120));
    border-radius: 50%;
    background: var(--icon-background, rgba(255,255,255, 0.2));
  }
  paper-icon-button:hover {
    background: var(--icon-hover-background, rgba(255,255,255, 0.4));
    color: var(--icon-hover-color, rgb(60, 60, 60));
  }

  div#control[top] paper-icon-button {
    box-shadow: 0px 0px 3px 0px rgba(31,31,31,0.5);
  }
  div#control[top] paper-icon-button:hover {
    background: rgba(255,255,255, 0.5);
    box-shadow: 0px 0px 6px 0px rgba(31,31,31,0.5);
  }
  /*paper-icon-button:hover:after {
    content: attr(label);
    position: absolute;
    top: 50%;
    right: 125%;
    padding: 0.5em;
    font-size: 0.75em;
    border-radius: 12px;
    background: rgba(255,255,255, 0.25);
    color: #1f1f1f;
  }*/
  .text {
    fill: currentColor !important;
    pointer-events: none;
    color: #1f1f1f;
    font-family: inherit !important;
    font-weight: inherit !important;
    letter-spacing: normal !important;
  }
  .svg-element-selectable {
    cursor: pointer;
    transform-origin: center center;
    -moz-transform-origin: 50% 50%;
  }
  .clicked {
    stroke-width: 1px !important;
    stroke: #183880 !important;
    stroke-linecap: round !important;
    stroke-linejoin: round !important;
    /*stroke-dashoffset: 0;
    stroke-dasharray: 0.5 2.5;
    will-change: transform;
    transform-origin: center center;
    animation: circular 3s infinite linear;*/
  }
  .selected {
    stroke: #EB4949 !important;
    stroke-width: 1.5px !important;
    stroke-linecap: round;
    stroke-linejoin: round;
    transform-origin: center center;
    will-change: transform;
    animation-name: selected-animation;
    animation-duration: 2s;
    animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    animation-iteration-count: infinite;
  }
  @keyframes selected-animation {
    0% {
      -webkit-transform: scale(1.0);
    }
    50% {
      -webkit-transform: scale(0.8);
      fill: #D91B1B;
    }
    100% {
      -webkit-transform: scale(1.0);
    }
  }
  @keyframes circular {
    to {
      stroke-dashoffset: 12;
    }
  }
</style>
<template>
  <div id="svgContainer">
  </div>
  <div id="control" top$="{{fullscreen}}">
    <paper-icon-button label="focus" icon="focus" on-tap="_resetZoom"></paper-icon-button>
    <paper-icon-button label="fullscreen" hidden$="{{fullscreen}}" icon="fullscreen" on-tap="_openFullscreen"></paper-icon-button>
    <paper-icon-button label="exit fullscreen" hidden$="{{!fullscreen}}" icon="fullscreen-exit" on-tap="_exitFullscreen"></paper-icon-button>
  </div>
</template>

<script>
  if (!SvgSource)
    var SvgSource = {};

  SvgElement = Polymer({
    is: 'svg-element',

    properties: {
      source: {
        type: String,
        observer: "_sourceChanged"
      },
      recentSource: {
        type: String,
        value: ''
      },
      selectable: {
        type: Object,
        value: function() { return {}; },
        observer: "_selectableChanged"
      },
      selected: {
        type: Object,
        value: function() { return {}; }
      },
      initial: {
        type: String,
        value: "",
        observer: "_initialChanged"
      },
      selectedClass: {
        type: String,
        value: "selected"
      },
      isZoomable: {
        type: Boolean,
        value: true
      },
      opened: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_openedChanged"
      },
      fullscreen: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      initiallyZoomToSelected: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      minZoom: {
        type: Number,
        value: 1
      },
      maxZoom: {
        type: Number,
        value: 5
      },
      zoomPartition: {
        type: Number,
        value: 3
      },
      height: {
        type: Number
      },
      width: {
        type: Number
      },
      mainG: {
        type: Object
      },
      svg: {
        type: Object
      },
      _d3Zoom: {
        type: Function
      }
    },

    listeners: {
      "xml-dom-import-finish": "_onXmlLoaded"
    },

    observers: [
      "_setSelected(selected.*)"
    ],

    _sourceChanged: function(source) {
      if (source && this.recentSource != source && this.opened) {
        if (!SvgSource[source])
          return;
        if (!SvgSource[source].node)
          return;
        this.recentSource = source;
        this.svg = d3.select(this.$.svgContainer).select('svg#main');
        if (this.svg && !this.svg.empty()) {
          this.$.svgContainer.removeChild(this.svg.node());
        }
        // import svg (came by data-socket-repeater)
        this._registerXML(SvgSource[source].node, source);
      }
    },

    _registerXML: function(xml, source) {
      // import svg to document
      var date = new Date();
      var svgNode = document.importNode(xml.cloneNode(true), true);
      // register zoom function
      this._d3Zoom = d3.behavior.zoom()
                       .scaleExtent([this.minZoom, this.maxZoom])
                       .on("zoom", this._zoom);

      // append imported svg to this element
      this.$.svgContainer.insertBefore(svgNode, this.$.svgContainer.firstChild);
      this.svg = d3.select(svgNode).attr("id", "main")
                                   .classed("svg-element", true)
                                   .call(this._d3Zoom);

      // set style for resizing
      this.svg.attr("preserveAspectRatio", "xMinYMin meet")
              .attr("height", null)
              .attr("width", null);

      this.mainG = this.svg.select("g")
                           .attr("id", "mainG")
                           .attr("transform", "translate(0,0)scale(1)");

      this.mainG.selectAll("text")
                .classed("text", true)  // for styling text
                .classed("svg-element", true); // style-scoping in polymer

      // get original dimensions
      var viewBox = this.svg.attr("viewBox").split(' ');
      this.width  = viewBox[2] - viewBox[0];
      this.height = viewBox[3] - viewBox[1];

      this.fire("xml-dom-import-finish", {source: source}, {bubbles: false})
    },

    _onXmlLoaded: function(e) {
      // set selectable elements
      this._selectableChanged();
      this.select(this.selected, this.selectedClass);
    },

    _zoom: function () {
      d3.select(this).select("g#mainG")
                     .attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    },

    _setSelected: function(change) {
      if(!change || !this.selected) return;
      this.select(this.selected, this.selectedClass);
    },

    _initialChanged: function(initial) {
      this.select(this.selected, this.selectedClass);
      this._resetZoom();
    },

    _openedChanged: function(opened) {
      if (!this.source || !opened) return;
      this._sourceChanged(this.source);
      this.async( function() {
        this._resetZoom();
      }, 750);
    },

    select: function(selected, selectedClass) {
      if (!this.mainG || !selectedClass) return;
      // previous selected elements: remove class for selected elements

      this.mainG.selectAll("." + selectedClass)
                .classed(selectedClass, false);

      var elems;
      var sel = "";
      for (var key in selected) {
        if (selected[key])
          sel += selected[key] + ','
      }
      sel = sel.slice(0,-1);
      if (!sel ||
          (elems = this.mainG.selectAll(sel)
                             .filter('.svg-element-selectable')).empty()) {
        if (this.opened)
          this._resetZoom();
        return;
      }

      var boundE, bounds = [];
      self = this;
      elems.each(
             function() {
               boundE = this.getBoundingClientRect();
               bounds[0] = (bounds[0] > boundE.left ? boundE.left : bounds[0]) || boundE.left;
               bounds[1] = (bounds[1] > boundE.top ? boundE.top : bounds[1]) || boundE.top;
               bounds[2] = (bounds[2] < boundE.right ? boundE.right : bounds[2]) || boundE.right;
               bounds[3] = (bounds[3] < boundE.bottom ? boundE.bottom : bounds[3]) || boundE.bottom;
               this.classList.add(selectedClass);
             });

      boundE = { left: bounds[0],
                 top: bounds[1],
                 height: bounds[3] - bounds[1],
                 width: bounds[2] - bounds[0] };

      if (this.opened)
        this._zoomToElement(boundE);
    },

    _zoomToElement: function(elem) {
      if (!elem) return;
      // calc centered zoom coordinates
      var transform = this._calcCenterZoom(elem);
      // call zoom to translate and scale
      this.svg.transition()
              .duration(350)
              .call(this._d3Zoom.translate(transform.translate).scale(transform.scale).event);
    },

    _calcCenterZoom: function(elem) {
      // get view height and width
      var view = this.getClientRects()[0];
      if (!view || !elem || view.height === 0 || view.width === 0)
        return {translate: [0,0], scale: 1};

      // calculate scale based on partioned view and dimensions of the element
      var boundE; var bboxE;
      if (elem.nodeType)
        boundE = elem.getBoundingClientRect();
      else boundE = elem;

      var bboxG = this.mainG.node().getBBox();
      var boundG = this.mainG.node().getBoundingClientRect();

      // absolute position (for angled or transioned element)
      var vs = bboxG.width/boundG.width || 1; // view scale
      var x = (boundE.left - boundG.left)*vs + bboxG.x;
      var y = (boundE.top - boundG.top)*vs + bboxG.y;

      // calculate zoom based on partions or minZoom or maxZoom
      // scaling and centering
      // view height/width in comparison tho viewboxheight/-width is important because of resizing by the browser
      // diffence in calculation by firefox in comparison to chromium based browsers
      if (view.width/view.height > 1)
        var scale = Math.min(this.width/(this.zoomPartition*vs*boundE.width), this.height/(this.zoomPartition*vs*boundE.height));
      else
        var scale = Math.max(this.width/(this.zoomPartition*vs*boundE.width), this.height/(this.zoomPartition*vs*boundE.height));

      if (scale < this.minZoom) scale = this.minZoom;
      if (scale > this.maxZoom) scale = this.maxZoom;

      if (view.width/view.height > this.width/this.height) {
        x = -scale*x + (this.height*view.width/view.height - scale*boundE.width*vs)/2;
        y = -scale*y + (this.height - scale*boundE.height*vs)/2;
      }
      else {
        x = -scale*x + (this.width - scale*boundE.width*vs)/2;
        y = -scale*y + (this.width*view.height/view.width - scale*boundE.height*vs)/2;
      }

      if (isNaN(x) || isNaN(y) || isNaN(scale))
        return {translate: [0,0], scale: 1};
      else
        return {translate: [x,y], scale: scale};
    },

    _selectableChanged: function() {
      if (!this.mainG || !this.selectable || this.selectable === {}) return;

      this.svg.on('contextmenu',
        function () {
          d3.event.preventDefault();
          var node = this;
          while (true) {
            if (node.nodeName && (node.nodeName.toLowerCase() === 'svg-element'))
              break;
            else if (node === window)
              return;
            else
              node = node.parentNode;
          }
          node._resetZoom();
        })

      // previous selectable elements: remove 'svg-element-selectable' class and click listener
      this.mainG.selectAll(".svg-element-selectable")
                .classed("svg-element-selectable", false)
                .on("click", null);
      this.mainG.selectAll(".clicked")
                .classed("clicked", false);

      // add 'svg-element-selectable' class and click listener
      self = this;
      for (var key in this.selectable)
        this.mainG.selectAll(this.selectable[key])
                  .classed("svg-element-selectable", true)  // for styling selectable
                  .classed("svg-element", true) // for style-scoping in polymer
                  .on("click",
                    function() {
                      // if (d3.event.defaultPrevented) return;
                      // get polymer-parent-node of the selectable node
                      // else d3 uses the last instance of svg-element-Object
                      var node = this;
                      while (true) {
                        if (node.nodeName && (node.nodeName.toLowerCase() === 'svg-element'))
                          break;
                        else if (node === window)
                          return;
                        else
                          node = node.parentNode;
                      }
                      node._zoomToElement(this);
                      node.mainG.selectAll('.clicked')
                                .classed("clicked", false);
                      this.classList.add("clicked");
                    })
                  .append("title")
                  .text(function() {
                        // var text = "";
                        // for (var prop in self.selectable[key].caption)
                        //   text += self.selectable[key].caption[prop] + " ";
                        // return text;
                        return key;
                   });
      for (var key in SvgSource[this.source].selectable)
        this.mainG.selectAll(SvgSource[this.source].selectable[key])
                  .classed("svg-element-selectable", true)  // for styling selectable
                  .classed("svg-element", true) // for style-scoping in polymer
                  .on("click",
                    function() {
                      // if (d3.event.defaultPrevented) return;
                      // get polymer-parent-node of the selectable node
                      // else d3 uses the last instance of svg-element-Object
                      var node = this;
                      while (true) {
                        if (node.nodeName && (node.nodeName.toLowerCase() === 'svg-element'))
                          break;
                        else if (node === window)
                          return;
                        else
                          node = node.parentNode;
                      }
                      node._zoomToElement(this);
                      node.mainG.selectAll('.clicked')
                                .classed("clicked", false);
                      this.classList.add("clicked");
                    })
                  .append("title")
                  .text(function() {
                        // var text = "";
                        // for (var prop in self.selectable[key].caption)
                        //   text += self.selectable[key].caption[prop] + " ";
                        // return text;
                        return key;
                   });
    },

    _resetZoom: function() {
      if (!this.mainG) return;
      // remove clicked class
      this.mainG.selectAll(".clicked")
                .classed("clicked", false);
      // zoom to selectedItems
      if (this.initiallyZoomToSelected && this.selected) {
        for (var key in this.selected) {
          if (this.selected[key] != "" && !(selected = this.mainG.selectAll(this.selected[key])
                                    .filter(".svg-element-selectable")).empty()) {
            this.select(this.selected, this.selectedClass);
            return;
          }
        }
      }
      // zoom to initial
      if (this.initial) {
        var initial;
        if (!(initial = this.mainG.selectAll(this.initial)
                                  .filter(".svg-element-selectable")).empty()) {
          this.select({initial: this.initial}, "initial");
          return;
        }
      }
      // zomm to mainG
      this._zoomToElement(this.mainG.node());
    },

    _openFullscreen: function() {
      this.fire("svg-open-fullscreen",{source: this.source, initial: this.initial, selected: this.selected});
    },

    _exitFullscreen: function() {
      this.fire("svg-exit-fullscreen");
    }
  });
</script>

<dom-module>

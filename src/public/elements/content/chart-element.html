<!-- Using d3.js-library -->

<dom-module id='chart-element'>
  <template>
<style>
  :host {
    font-family: inherit;
    font-size: 0.75em;
    color: currentColor;
    letter-spacing: normal !important;
    border-radius: inherit;
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
    -webkit-touch-callout: none; -webkit-tap-highlight-color:rgba(0,0,0,0);
  	overflow: visible;
    visibility: visible;
    -webkit-touch-callout: none !important;
      -webkit-user-select: none !important;
       -khtml-user-select: none !important;
         -moz-user-select: none !important;
          -ms-user-select: none !important;
              user-select: none !important;
  }
  section#menu, section#info, section#legend {
    display: flex;
    flex-direction: column;
    align-content: stretch;
    align-items: stretch;
    justify-content: center;
    position: absolute;
    padding: 0.75em;
    background: white;
    border-radius: 4px;
    box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                0 1px 5px 0 rgba(0, 0, 0, 0.12),
                0 3px 1px -2px rgba(0, 0, 0, 0.2);
  }
  button-element {
    padding: 0.5em;
    border-radius: 0px;
  }
  text {
    fill: currentColor !important;
    pointer-events: none;
    font-family: inherit !important;
    font-weight: inherit !important;
    letter-spacing: normal !important;
  }
  svg#svg {
    position: absolute;
  }
  svg.button {
    fill: currentColor;
    fill-opacity: 0.5;
    transition: fill-opacity 200ms ease;
    /*shape-rendering: crispEdges;*/
  }
  svg.button rect {
    fill: white;
    fill-opacity: inherit;
  }
  svg.button:hover {
    fill-opacity: 1;
  }
  g#chart text{
    font-size: 1em;
  }
  g#brush text{
    font-size: 0.5em;
  }
  g#chart rect.plot {
    fill: #BDE2F1;
    fill-opacity: 0.25;
    stroke: #345475;
    stroke-opacity: 0.5;
    shape-rendering: crispEdges;
    stroke-width: 1px;
  }
  g#brushX rect.background, g#brushY rect.background {
    fill: white;
    fill-opacity: 0.5;
    stroke: #345475;
    stroke-opacity: 0.2;
    shape-rendering: crispEdges;
    stroke-width: 1px;
  }
  g.grid .tick {
    stroke: #345475;
    stroke-opacity: 0.2;
  }
  g.grid path {
    stroke-width: 0;
  }
  g.axis path, g.axis line {
    fill: none;
    stroke: #345475;
    stroke-opacity: 0.1;
    shape-rendering: crispEdges;
    stroke-width: 1.5px;
  }
  g#chart g.axis path, g#chart g.axis line {
    stroke-opacity: 0.3;
  }
  g#focus line.focus.line {
      fill: none;
      stroke: #345475;
      stroke-opacity: 0.4;
      stroke-width: 2px;
      stroke-dasharray: 5;
  }
  g.brush rect.extent {
    stroke: #345475;
    fill: #005B82;
    fill-opacity: 0.25;
    shape-rendering: crispEdges;
  }
  g.brush rect.extent.clamp {
    fill-opacity: 0.5;
  }
</style>

  <svg id='svg' version='1.1' xmlns='http://www.w3.org/2000/svg'>
    <g id='brushX'>
      <rect class='background'></rect>
      <g class='axis'></g>
      <g class='brush'></g>
    </g>
    <g id='brushY'>
      <rect class='background'></rect>
      <g class='axis'></g>
      <g class='brush'></g>
    </g>
    <g id='chart'>
      <clipPath id='clip'>
        <rect x='0' y='0'></rect>
      </clipPath>
      <rect class='plot'></rect>
      <g class='x axis'></g>
      <g class='y axis'></g>
      <g class='x grid'></g>
      <g class='y grid'></g>
      <g id='focus'>
        <line class='focus line x' y1='0'></line>
        <line class='focus line y' x1='0'></line>
        <text class='focus text x' y='4'></text>
        <text class='focus text y' x='4'></text>
      </g>
      <g id='graphs'></g>
      <g id='legend'></g>
    </g>
    <svg id='menubutton' class='button' preserveAspectRatio='xMidYMid meet' on-tap='toggleMenu'>
      <rect></rect>
      <g><svg viewBox='0 0 24 24'>
        <path d='M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z'/>
         </svg></g>
    </svg>
  </svg>

  <section id='info' on-tap='_toggleInfo' hidden>
    <section id='infoX'></section>
    <section id='infoY'></section>
  </section>
  <section id='menu' hidden>
    <dropdown-selector label="y-Skalierung" attr-for-selected="scale" selected="{{yScale}}">
        <iron-icon icon="scale" class"left"></iron-icon>
        <button-element scale='linear'>linear</button-element>
        <button-element scale='sqrt'>√</button-element>
        <button-element scale='ln'>ln</button-element>
        <button-element scale='log'>log₁₀</button-element>
    </dropdown-selector>
    <dropdown-selector label="Interpolator" attr-for-selected="interpolate" selected="{{interpolation}}">
        <iron-icon icon="interpolate" class"left"></iron-icon>
        <button-element interpolate='linear'>linear</button-element>
        <button-element interpolate='basis'>basis</button-element>
        <button-element interpolate='cardinal'>cardinal</button-element>
        <button-element interpolate='monotone'>monotone</button-element>
        <button-element interpolate='step-before'>step-before</button-element>
        <button-element interpolate='step-after'>step-after</button-element>
    </dropdown-selector>
    <toggle-button-element checked="[[noDots]]" on-change="changeDots"><iron-icon icon="dots"></iron-icon>Punkte</toggle-button-element>
    <toggle-button-element checked="[[noLines]]" on-change="changeLines"><iron-icon icon="line"></iron-icon>Linien</toggle-button-element>
  </section>

  <content id='collector' select='graph-element'></content>
</template>

  <script>
    ChartElement = Polymer({
      is: 'chart-element',

      behaviors: [Polymer.IronResizableBehavior],

      properties: {
        margin: {
          type: Object,
          value: function() {
            return {  top: 12,
                      right: 24,
                      bottom: 36,
                      left: 60 };
          }
        },
        brushWidth: {
          type: Number,
            value: 36
        },
        clamp: {
          type: Boolean,
          value: true
        },
        clampExtend: {
          type: Number,
          value: 1000
        },
        isClamping: {
          type: Boolean,
          value: false
        },
        ticks: {
          type: Number,
          value: 6
        },
        yScale: {
          type: String,
          value: 'linear',
          observer: 'changeScale'
        },
        interpolation: {
          type: String,
          value: 'cardinal',
          observer: 'changeInterpolation'
        },
        noDots: {
          type: Boolean,
          value: false
        },
        noLines: {
          type: Boolean,
          value: false
        },

        _width: Object,
        _height: Object,

        _chart: Object,

        _x: {
          type: Object,
          value: function() { return d3.scaleTime(); }
        },
        _x2: {
          type: Object,
          value: function() { return d3.scaleTime(); }
        },
        _y: Object,
        _y2: Object,

        _xAxis: Object,
        _yAxis: Object,

        _brushBehaviorX: Object,
        _brushX: Object,
        _brushAxisX: Object,
        _brushGridX: Object,

        _brushBehaviorY: Object,
        _brushY: Object,
        _brushAxisY: Object,
        _brushGridY: Object,

        _focusX: Object,
        _focusTextX: Object,
        _focusY: Object,
        _focusTextY: Object,

        _legend: Object,
        _info: Object
      },

      get _self () {
        return this;
      },

      get _graphs () {
        return this.getEffectiveChildren();
      },

      get _parent () {
        if (this.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          return this.parentNode.host;
        }
        return this.parentNode;
      },

      listeners: {
        'iron-resize': '_sizeChanged'
      },

      created: function() {
        d3.timeFormatDefaultLocale({
          'dateTime': '%x %X',
          'date': '%d.%m.%Y',
          'time': '%H:%M:%S',
          'periods': ['', ''],
          'days': ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
          'shortDays': ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
          'months': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
          'shortMonths': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Agu', 'Sep', 'Okt', 'Nov', 'Dez']
        });
        d3.formatDefaultLocale({
          "decimal": ",",
          "thousands": ".",
          "grouping": [3],
          "currency": ["", "\u00a0€"]
        });
      },

      ready: function() {
        this._buildLayout();
      },

      _sizeChanged: function(e) {
        this.debounce('resize', this._sizeLayout, 50);
      },

      _buildLayout: function() {
        d3.select(this.$.svg).attr('preserveAspectRatio', 'xMinYMin meet')
                             .attr('height', null)
                             .attr('width', null);
        this._y  = this._createNumberScale(this.yScale, this._y);
        this._y2 = this._createNumberScale(this.yScale, this._y2);

        this._xAxis = this._createAxis(this._x, 'bottom', 'time');
        this._yAxis = this._createAxis(this._y, 'left');

        this._chart = d3.select(this.$.chart)
                        .on('mouseenter', this._showFocus.bind(this))
                        .on('mousemove',  this._drawFocus.bind(this))
                        .on('mouseleave', this._hideFocus.bind(this));

        this._chart.select('g.x.axis')
                   .call(this._xAxis);

        this._chart.select('g.y.axis')
                   .call(this._yAxis);

        this._focusX = this._chart.select('line.focus.line.x')
                                  .attr('clip-path', 'url(#clip)');
        this._focusY = this._chart.select('line.focus.line.y')
                                  .attr('clip-path', 'url(#clip)');

        // this._brushBehaviorX = d3.svg.brush()
        //                          .x(this._x2)
        //                          .on('brush', this._brushedX.bind(this._self));
        // this._brushX = d3.select(this.$.brushX);
        // this._brushAxisX = this._createAxis(this._x2, 'top');
        // this._brushX.select('g.axis')
        //             .call(this._brushAxisX);
        // this._brushX.select('g.brush')
        //             .call(this._brushBehaviorX)
        //             .on('contextmenu', function() {
        //                 d3.event.preventDefault();
        //                 this._brushBehaviorX.clear();
        //                 this._brushedX();
        //              }.bind(this._self));
        //
        // this._brushBehaviorY = d3.svg.brush()
        //                          .y(this._y2)
        //                          .on('brush', this._brushedY.bind(this._self));
        // this._brushY = d3.select(this.$.brushY);
        // this._brushAxisY = this._createAxis(this._y2, 'right');
        // this._brushY.select('g.axis')
        //             .call(this._brushAxisY);
        // this._brushY.select('g.brush')
        //             .call(this._brushBehaviorY)
        //             .on('contextmenu', function() {
        //                 d3.event.preventDefault();
        //                 this._brushBehaviorY.clear();
        //                 this._brushedY();
        //              }.bind(this._self))
        //             .on('ondblclick', function() {
        //                 d3.event.preventDefault();
        //                 this._brushBehaviorY.clear();
        //                 this._brushedY();
        //              }.bind(this._self));

        this._info = d3.select(this.$.info);
        this._legend = d3.select(this.$.legend);

        d3.select(this.$.svg).selectAll('g.tick,g.tick line,g.tick text,g path.domain,rect,g.axis')
                             .classed('style-scope', true)
                             .classed('chart-element', true);
      },

      _sizeLayout: function() {
        this._height = Math.max(this._parent.offsetHeight, 200);
        this._width = Math.max(this._parent.offsetWidth, 300);

        this._width = this._width - this.margin.left - this.margin.right - this.brushWidth;
        this._height = this._height - this.margin.bottom - this.margin.top - this.brushWidth;

        this._x.range([0, this._width]);
        this._y.range([this._height, 0]);

        this._x2.range([0, this._width]),
        this._y2.range([this._height, 0]);

        d3.select(this.$.svg).attr('viewBox', '0 0 ' + this._parent.offsetWidth + ' ' + this._parent.offsetHeight);


        d3.select(this.$.menubutton).attr('x', (this.margin.left + this._width + 1)+'px')
                                    .attr('y', (this.margin.top)+'px')
                                    .attr('height', this.brushWidth+'px')
                                    .attr('width', this.brushWidth+'px')
                                    .select('rect')
                                    .attr('height', this.brushWidth+'px')
                                    .attr('width', this.brushWidth+'px');
        d3.select(this.$.menubutton).select('g')
                                    .attr('transform', 'translate(8,0)')
                                    .select('svg')
                                    .attr('width', (this.brushWidth - 16)+'px' );
        d3.select(this.$.menu).attr('style', 'right:'+(this.margin.right+this.brushWidth+2)+'px; top:'+(this.margin.top+this.brushWidth+2)+'px');

        this._chart.attr('transform', 'translate(' + this.margin.left + ',' + (this.brushWidth + this.margin.top) + ')');

        // Limiting Projection to Margin
        this._chart.selectAll('clipPath#clip rect')
                   .attr('width', this._width)
                   .attr('height', this._height);

        this._chart.select('rect.plot')
                  .attr('width', this._width)
                  .attr('height', this._height);

        this._chart.select('g.x.axis')
                  .attr('transform', 'translate(0,' + this._height + ')');

        this._chart.select('g.x.grid')
                  .attr('transform', 'translate(0,' + this._height + ')')
                  .call(this._createAxis(this._x, 'bottom', 'time')
                            .tickSize(-this._height, 0, 0)
                            .tickFormat(''));
        this._chart.select('g.y.grid')
                  .call(this._createAxis(this._y, 'left')
                            .tickSize(-this._width, 0, 0)
                            .tickFormat(''));

        this._focusX.attr('y2', this._height);
        this._focusY.attr('x2', this._width);

        // this._brushX.attr('transform', 'translate(' + this.margin.left + ',' + (this.margin.top + this.brushWidth)+ ')');
        // this._brushX.select('rect.background')
        //               .attr('width', this._width)
        //               .attr('height', this.brushWidth)
        //               .attr('transform', 'translate(0,-' + this.brushWidth + ')');
        // this._brushX.select('.brush')
        //             .selectAll('rect')
        //               .attr('y',  -this.brushWidth)
        //               .attr('width', this._width)
        //               .attr('height', this.brushWidth);
        //
        // this._brushY.attr('transform', 'translate(' + (this.margin.left + this._width) + ',' + (this.margin.top + this.brushWidth) + ')');
        // this._brushY.select('rect.background')
        //               .attr('width', this.brushWidth)
        //               .attr('height', this._height)
        //               .attr('transform', 'translate(0,0)');
        // this._brushY.select('.brush')
        //             .selectAll('rect')
        //               .attr('x',  0)
        //               .attr('width', this.brushWidth)
        //               .attr('height', this._height);

        this._info.attr('style', 'left:'+(this.margin.left+4)+'px; top:'+(this.margin.top+this.brushWidth+3)+'px');
        this._legend.attr('style', 'right:'+(this.margin.right+this.brushWidth+2)+'px; top:'+(this.margin.top+this.brushWidth+2)+'px');

        d3.select(this.$.svg).selectAll('g.tick,g.tick line,g.tick text,g path.domain,rect,g.axis,text')
                             .classed('style-scope', true)
                             .classed('chart-element', true);
      },

      _createNumberScale: function(option, y) {
        var scale;
        switch (option) {
          case 'ln':
            scale = d3.scaleLog().base(Math.E); break;
          case 'log':
            scale = d3.scaleLog(); break;
          case 'sqrt':
            scale = d3.scaleSqrt(); break;
          default:
            scale = d3.scaleLinear();
        }
        return scale;
      },

      _createAxis: function(scale, orient, kind) {
        var axis;
        switch (orient) {
          case 'bottom':
            axis = d3.axisBottom(); break;
          case 'left':
            axis = d3.axisLeft(); break;
          case 'right':
            axis = d3.axisRight(); break;
          case 'top':
            axis = d3.axisTop();
        }
        axis.scale(scale)
            .ticks(this.ticks);
        if (kind === "time")
          axis.tickFormat(this.timeFormat);
        return axis;
      },

      timeFormat: function (date) {
        var formatMillisecond = d3.timeFormat(".%L"),
            formatSecond = d3.timeFormat(":%S"),
            formatMinute = d3.timeFormat("%H:%M"),
            formatHour = d3.timeFormat("%H:%M"),
            formatDay = d3.timeFormat("%d.%a"),
            formatWeek = d3.timeFormat("%d. %b"),
            formatMonth = d3.timeFormat("%B"),
            formatYear = d3.timeFormat("%Y");

        return (d3.timeSecond(date) < date ? formatMillisecond
              : d3.timeMinute(date) < date ? formatSecond
              : d3.timeHour(date) < date ? formatMinute
              : d3.timeDay(date) < date ? formatHour
              : d3.timeMonth(date) < date ? (d3.timeWeek(date) < date ? formatDay : formatWeek)
              : d3.timeYear(date) < date ? formatMonth
              : formatYear)(date);
      },
      timeFormatRange: function (date, r) {
        console.log(date);
        var formatMillisecond = d3.timeFormat("%S.%L"),
            formatSecond = d3.timeFormat("%M:%S.%L"),
            formatMinute = d3.timeFormat("%X"),
            formatHour = d3.timeFormat("%X"),
            formatDay = d3.timeFormat("%d.%a %X"),
            formatWeek = d3.timeFormat("%d. %b %X"),
            formatMonth = d3.timeFormat("%B %H:%M"),
            formatYear = d3.timeFormat("%Y");

        return (d3.timeSecond(r[0]).valueOf() === d3.timeSecond(r[1]).valueOf() ? formatMillisecond
              : d3.timeMinute(r[0]).valueOf() === d3.timeMinute(r[1]).valueOf() ? formatSecond
              : d3.timeHour(r[0]).valueOf() === d3.timeHour(r[1]).valueOf() ? formatMinute
              : d3.timeDay(r[0]).valueOf() === d3.timeDay(r[1]).valueOf() ? formatHour
              : d3.timeMonth(r[0]).valueOf() === d3.timeMonth(r[1]).valueOf() ? (d3.timeWeek(r[0]).valueOf() === d3.timeWeek(r[1]).valueOf() ? formatDay : formatWeek)
              : d3.timeYear(r[0]).valueOf() === d3.timeYear(r[1]).valueOf() ? formatMonth
              : formatYear)(date);
      },

      redraw: function () {
        this.debounce('redraw', function() { this._redraw() }, 100);
      },

      _redraw: function () {
        this._chart.select('.x.axis').transition(100).call(this._xAxis);
        this._chart.select('.y.axis').transition(100).call(this._yAxis);
        this._chart.select('.x.grid').transition(100)
                   .call(this._createAxis(this._x, 'bottom', 'time')
                             .tickSize(-this._height, 0, 0)
                             .tickFormat(''));
        this._chart.select('.y.grid').transition(100)
                   .call(this._createAxis(this._y, 'left')
                             .tickSize(-this._width, 0, 0)
                             .tickFormat(''));
        // this._brushBehaviorX.extent(this._brushBehaviorX.extent());
        // this._brushX.select('.axis').transition(100).call(this._brushAxisX);
        // // this._brushX.select('.grid').transition(100).call(this._brushGridX);
        // this._brushX.select('.brush').transition(100).call(this._brushBehaviorX)
        // this._brushBehaviorY.extent(this._brushBehaviorY.extent());
        // this._brushY.select('.axis').transition(100).call(this._brushAxisY);
        // // this._brushY.select('.grid').transition(100).call(this._brushGridY);
        // this._brushY.select('.brush').transition(100).call(this._brushBehaviorY)
        // d3.select(this.$.svg).selectAll('g.tick,g.tick line,g.tick text,g path.domain,rect,g.axis,text')
        //                      .classed('style-scope', true)
        //                      .classed('chart-element', true);
        this._graphs.forEach(function(g) { g.redraw(); });
      },

      _brushedX: function() {
        // this.isClamping = (this.clamp === true && this._brushBehaviorX.empty() === false && this._x2.domain()[1] - this._brushBehaviorX.extent()[1] < this.clampExtend);
        // if (this.isClamping) {
        //   this._brushBehaviorX.extent( [ this._brushBehaviorX.extent()[0], this._x2.domain()[1] ] );
        //   this._brushX.select('rect.extent').classed('clamp', true);
        // }
        // else
        //   this._brushX.select('rect.extent').classed('clamp', false);
        // this._x.domain(this._brushBehaviorX.empty() ? this._x2.domain() : this._brushBehaviorX.extent());
        // this.redraw();
      },
      _brushedY: function() {
        // this._y.domain(this._brushBehaviorY.empty() ? this._y2.domain() : this._brushBehaviorY.extent());
        // this.redraw();
      },

      setAllDomains: function () {
        this.debounce('domains', function() { this._setAllDomains() }, 100);
      },

      setAllDomains: function () {
        var graphs = this._graphs;
        var domainX, domainY = [0, 0], domainTmp, v;
        domainX  = [ d3.min(graphs,function(g){ return d3.min(g.values,function(v){ return v.x; }) }) ,
                     d3.max(graphs,function(g){ return d3.max(g.values,function(v){ return v.x; }) }) ];
        domainTmp  = [ d3.min(graphs,function(g){ return d3.min(g.values,function(v){ return v.y; }) }),
                     d3.max(graphs,function(g){ return d3.max(g.values,function(v){ return v.y;})}) ];

        v = (domainTmp[0]).toExponential().split('e');
        domainY[0] = (Math.floor(v[0])) * Math.pow(10,parseInt(v[1],10));
        v = (domainTmp[1]).toExponential().split('e');
        domainY[1] = (Math.ceil(v[0]) + 1) * Math.pow(10,parseInt(v[1],10));

        // this._x2.domain(domainX);
        // this._y2.domain(domainY);
        // if (!this._brushBehaviorX.empty()) {
        //   domainTmp = this._brushBehaviorX.extent();
        //   if ( domainTmp[0] <= domainX[0] ) {
        //     this._brushBehaviorX.extent( [domainX[0], domainTmp[1]] );
        //     domainTmp = this._brushBehaviorX.extent();
        //     if (this.isClamping === true || domainTmp[1] <= domainX[0]) {
        //       this._brushBehaviorX.clear();
        //     }
        //   }
        //   else if (this.isClamping === true) {
        //     this._brushBehaviorX.extent( [domainTmp[0], domainX[1]] );
        //   }
        //   domainX = this._brushBehaviorX.extent();
        //
        // }
        // if (!this._brushBehaviorY.empty()) {
        //   domainY = this._brushBehaviorY.extent();
        // }
        this._x.domain(domainX);
        this._y.domain(domainY);
        this.redraw();
      },

      _showFocus: function() {
        d3.select('g#focus').style('opacity', 1);
      },
      _drawFocus: function() {
        var x = d3.event.layerX - this.margin.left;
        var y = d3.event.layerY - this.margin.top - this.brushWidth;
        var domain = this._y.domain(),
            p = d3.precisionFixed((domain[1]-domain[0])/100),
            fn = d3.format("." + p + "f")
            ft = d3.timeFormat("%X.%L");
        this._focusX.attr('transform', 'translate(' + x + ',0)');
        this._chart.select('text.x.focus.text').attr('transform', 'translate(' + (x + 4) + ',' + (this._height - 8) + ')')
                   .text(ft(this._x.invert(x)));
        this._focusY.attr('transform', 'translate(0,' + (y) + ')');
        this._chart.select('text.y.focus.text').attr('transform', 'translate(0,' + (y - 4) + ')')
                   .text(fn(this._y.invert(y)));
      },
      _hideFocus: function() {
        d3.select('g#focus').transition(1000).style('opacity', 0);
      },
      _updateInfo: function(d) {
        this.$.info.removeAttribute('hidden');
        var dY = this._y.domain(),
            p = d3.precisionFixed((dY[1]-dY[0])/100),
            fn = d3.format("." + p + "f");
        this.$.infoX.innerText = 'x = ' + this.timeFormatRange(d.x, this._x.domain());
        this.$.infoY.innerText = 'y = ' + fn(d.y);
      },
      _toggleInfo: function() {
        if (this.$.info.hasAttribute('hidden')) {
          this.$.info.removeAttribute('hidden');
        }
        else {
          this.$.info.setAttribute('hidden', true);
        }
      },
      toggleMenu: function() {
        if (this.$.menu.hasAttribute('hidden')) {
          this.$.menu.removeAttribute('hidden');
        }
        else {
          this.$.menu.setAttribute('hidden', true);
        }
      },
      changeInterpolation: function(newValue, oldValue) {
        if (oldValue === undefined) return;
        this._graphs.forEach(
          function(g) {
            if (g._lineFunction)
              g._lineFunction.interpolate(newValue);
          });
        this.redraw();
      },
      changeScale: function(newValue, oldValue) {
        if (oldValue === undefined) return;
        this._buildLayout();
        this._sizeLayout();
        this.redraw();
      },
      changeDots: function(e) {
        this._graphs.forEach(
          function(g) {
            g.set('noDots', e.target.checked)
          });
      },
      changeLines: function(e) {
        this._graphs.forEach(
          function(g) {
            g.set('noLine', e.target.checked)
          });
      }
    });

  </script>

</dom-module>

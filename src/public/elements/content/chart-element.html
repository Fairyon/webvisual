<!-- Using d3.js-library -->

<dom-module id='chart-element'>
<link rel='import' href='../style/app-theme.html'/>
<style>
  :host {
    font-family: inherit;
    font-size: 0.75em;
    color: currentColor;
    letter-spacing: normal !important;
    border-radius: inherit;
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
    -webkit-touch-callout: none; -webkit-tap-highlight-color:rgba(0,0,0,0);
  	overflow: hidden;
    visibility: visible;
    -webkit-touch-callout: none !important;
      -webkit-user-select: none !important;
       -khtml-user-select: none !important;
         -moz-user-select: none !important;
          -ms-user-select: none !important;
              user-select: none !important;
  }
  section#menu {
    display: block;
    position: absolute;
    padding: 0.75em;
    background: white;
    border-radius: 4px;
    box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                0 1px 5px 0 rgba(0, 0, 0, 0.12),
                0 3px 1px -2px rgba(0, 0, 0, 0.2);
  }
  text {
    fill: currentColor !important;
    pointer-events: none;
    font-family: inherit !important;
    font-weight: inherit !important;
    letter-spacing: normal !important;
  }
  svg#svg {
    position: absolute;
  }
  svg.button {
    fill: currentColor;
    fill-opacity: 0.5;
    transition: fill-opacity 200ms ease;
    shape-rendering: crispEdges;
  }
  svg.button rect {
    fill: white;
    fill-opacity: inherit;
  }
  svg.button:hover {
    fill-opacity: 1;
  }
  g#chart text{
    font-size: 1em;
  }
  g#brush text{
    font-size: 0.5em;
  }
  g#chart rect.plot {
    fill: #BDE2F1;
    fill-opacity: 0.25;
    stroke: #345475;
    stroke-opacity: 0.5;
    shape-rendering: crispEdges;
    stroke-width: 1px;
  }
  g#brushX rect.background, g#brushY rect.background {
    fill: white;
    fill-opacity: 0.5;
    stroke: #345475;
    stroke-opacity: 0.2;
    shape-rendering: crispEdges;
    stroke-width: 1px;
  }
  g.grid .tick {
    stroke: #345475;
    stroke-opacity: 0.2;
  }
  g.grid path {
    stroke-width: 0;
  }
  g.axis path, g.axis line {
    fill: none;
    stroke: #345475;
    stroke-opacity: 0.1;
    shape-rendering: crispEdges;
    stroke-width: 1.5px;
  }
  g#chart g.axis path, g#chart g.axis line {
    stroke-opacity: 0.3;
  }
  g#focus line.focus.line {
      fill: none;
      stroke: #345475;
      stroke-opacity: 0.4;
      stroke-width: 2px;
  }
  g.brush rect.extent {
    stroke: #345475;
    fill: #005B82;
    fill-opacity: 0.25;
    shape-rendering: crispEdges;
  }
  g.brush rect.extent.clamp {
    fill-opacity: 0.5;
  }
</style>

<template>
  <svg id='svg' version='1.1' xmlns='http://www.w3.org/2000/svg'>
    <g id='brushX'>
      <rect class='background'></rect>
      <g class='axis'></g>
      <!-- <g class='grid'></g> -->
      <g class='brush'></g>
    </g>
    <g id='brushY'>
      <rect class='background'></rect>
      <g class='axis'></g>
      <!-- <g class='grid'></g> -->
      <g class='brush'></g>
    </g>
    <g id='chart'>
      <clipPath id='clip'>
        <rect x='0' y='0'></rect>
      </clipPath>
      <rect class='plot'></rect>
      <g class='x axis'></g>
      <g class='y axis'></g>
      <g class='x grid'></g>
      <g class='y grid'></g>
      <g id='focus'>
        <line class='focus line x' y1='0'></line>
        <line class='focus line y' x1='0'></line>
      </g>
      <g id='graphs'></g>
    </g>
    <svg id='menubutton' class='button' preserveAspectRatio='xMidYMid meet' on-tap='toggleMenu'>
      <rect></rect>
      <g><svg viewBox='0 0 24 24'>
        <path d='M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z'/>
         </svg></g>
    </svg>
  </svg>

  <section id='menu' hidden>
    <paper-input>      <div prefix>$</div>
      <paper-icon-button suffix icon="clear"></paper-icon-button></paper-input>
    <paper-dropdown-menu label="Interpolierung">
      <iron-selector class="dropdown-content" attr-for-selected="interpolate" selected="{{interpolation}}">
        <paper-item interpolate='linear'>linear</paper-item>
        <paper-item interpolate='basis'>basis</paper-item>
        <paper-item interpolate='cardinal'>cardinal</paper-item>
        <paper-item interpolate='monotone'>monotone</paper-item>
        <paper-item interpolate='step-before'>step-before</paper-item>
        <paper-item interpolate='step-after'>step-after</paper-item>
      </iron-selector>
    </paper-dropdown-menu>
    <paper-dropdown-menu label="Skalierung">
      <iron-selector class="dropdown-content" attr-for-selected="scale" selected="{{yScale}}">
        <paper-item scale='linear'>linear</paper-item>
        <paper-item scale='ln'>ln</paper-item>
        <paper-item scale='log'>log₁₀</paper-item>
      </iron-selector>
    </paper-dropdown-menu>
  </section>

  <content id='collector' select='graph-element'></content>
</template>

  <script>
    ChartElement = Polymer({
      is: 'chart-element',

      behaviors: [Polymer.IronResizableBehavior],

      properties: {
        margin: {
          type: Object,
          value: function() {
            return {  top: 12,
                      right: 24,
                      bottom: 36,
                      left: 60 };
          }
        },
        brushWidth: {
          type: Number,
            value: 36
        },
        clamp: {
          type: Boolean,
          value: true
        },
        clampExtend: {
          type: Number,
          value: 1000
        },
        isClamping: {
          type: Boolean,
          value: false
        },
        ticks: {
          type: Number,
          value: 6
        },
        yScale: {
          type: String,
          value: 'linear',
          observer: 'changeScale'
        },
        interpolation: {
          type: String,
          value: 'cardinal',
          observer: 'changeInterpolation'
        },

        _width: {},
        _height: {},

        _chart: {},

        _x: {
          type: Object,
          value: function() { return d3.time.scale(); }
        },
        _x2: {
          type: Object,
          value: function() { return d3.time.scale(); }
        },
        _y: {},
        _y2: {},

        _xAxis: {},
        _yAxis: {},

        _brushBehaviorX: {},
        _brushX: {},
        _brushAxisX: {},
        _brushGridX: {},

        _brushBehaviorY: {},
        _brushY: {},
        _brushAxisY: {},
        _brushGridY: {},

        _focusX: {},
        _focusY: {}
      },

      get _self () {
        return this;
      },

      get _graphs () {
        return this.getEffectiveChildren();
      },

      get _parent () {
        if (this.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
          return this.parentNode.host;
        }
        return this.parentNode;
      },

      listeners: {
        'iron-resize': '_sizeChanged'
      },

      created: function() {
        this.locale = d3.locale({
          'decimal': ',',
          'thousands': '.',
          'grouping': [3],
          'dateTime': '%a %b %e %X %Y',
          'date': '%d.%m.%Y',
          'time': '%H:%M:%S',
          'periods': ['', ''],
          'days': ['Sonntag', 'Montag', 'Dienstag', 'Mittwoch', 'Donnerstag', 'Freitag', 'Samstag'],
          'shortDays': ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'],
          'months': ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
          'shortMonths': ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Agu', 'Sep', 'Okt', 'Nov', 'Dez']
        });

        this.timeFormat = this.locale.timeFormat.multi([
        	['.%L', function(d) { return d.getMilliseconds(); }],
        	[':%S', function(d) { return d.getSeconds(); }],
        	['%M', function(d) { return d.getMinutes(); }],
        	['%_H:%M', function(d) { return d.getHours(); }],
        	['%a %d', function(d) { return d.getDay() && d.getDate() != 1; }],
        	['%b %d', function(d) { return d.getDate() != 1; }],
        	['%B', function(d) { return d.getMonth(); }],
        	['%Y', function() { return true; }]
        ]);

        this.numberFormat = this.locale.numberFormat();
      },

      ready: function() {
        this._buildLayout();
      },

      _sizeChanged: function(e) {
        this.debounce('resize', this._sizeLayout, 50);
      },

      _buildLayout: function() {
        d3.select(this.$.svg).attr('preserveAspectRatio', 'xMinYMin meet')
                             .attr('height', null)
                             .attr('width', null);
        console.log(this.yScale);
        this._y  = this._createNumberScale(this.yScale, this._y);
        this._y2 = this._createNumberScale(this.yScale, this._y2);

        this._xAxis = this._createTimeAxis(this._x, 'bottom');
        this._yAxis = this._createNumberAxis(this._y, 'left');

        this._chart = d3.select(this.$.chart)
                        .on('mouseenter', this._showFocus.bind(this))
                        .on('mousemove',  this._drawFocus.bind(this))
                        .on('mouseleave', this._hideFocus.bind(this));

        this._chart.select('g.x.axis')
                   .call(this._xAxis);

        this._chart.select('g.y.axis')
                   .call(this._yAxis);

        this._focusX = this._chart.select('line.focus.line.x')
                                  .attr('clip-path', 'url(#clip)');
        this._focusY = this._chart.select('line.focus.line.y')
                                  .attr('clip-path', 'url(#clip)');

        this._brushBehaviorX = d3.svg.brush()
                                 .x(this._x2)
                                 .on('brush', this._brushedX.bind(this._self));
        this._brushX = d3.select(this.$.brushX);
        this._brushAxisX = this._createTimeAxis(this._x2, 'top');
        // this._brushGridX = d3.svg.axis().scale(this._x2).orient('top').tickFormat('');
        this._brushX.select('g.axis')
                    .call(this._brushAxisX);
        // this._brushX.select('g.grid')
        //              .call(this._brushGridX);
        this._brushX.select('g.brush')
                    .call(this._brushBehaviorX)
                    .on('contextmenu', function() {
                        d3.event.preventDefault();
                        this._brushBehaviorX.clear();
                        this._brushedX();
                     }.bind(this._self));

        this._brushBehaviorY = d3.svg.brush()
                                 .y(this._y2)
                                 .on('brush', this._brushedY.bind(this._self));
        this._brushY = d3.select(this.$.brushY);
        this._brushAxisY = this._createNumberAxis(this._y2, 'right');
        // this._brushGridY = d3.svg.axis().scale(this._y2).orient('right').tickFormat('');
        this._brushY.select('g.axis')
                    .call(this._brushAxisY);
        // this._brushY.select('g.grid')
        //             .call(this._brushGridY);
        this._brushY.select('g.brush')
                    .call(this._brushBehaviorY)
                    .on('contextmenu', function() {
                        d3.event.preventDefault();
                        this._brushBehaviorY.clear();
                        this._brushedY();
                     }.bind(this._self))
                    .on('ondblclick', function() {
                        d3.event.preventDefault();
                        this._brushBehaviorY.clear();
                        this._brushedY();
                     }.bind(this._self));

        d3.select(this.$.svg).selectAll('g.tick,g.tick line,g.tick text,g path.domain,rect,g.axis')
                             .classed('style-scope', true)
                             .classed('chart-element', true);
      },

      _sizeLayout: function() {
        this._height = Math.max(this._parent.offsetHeight, 200);
        this._width = Math.max(this._parent.offsetWidth, 300);

        this._width = this._width - this.margin.left - this.margin.right - this.brushWidth;
        this._height = this._height - this.margin.bottom - this.margin.top - this.brushWidth;

        this._x.range([0, this._width]);
        this._y.range([this._height, 0]);

        this._x2.range([0, this._width]),
        this._y2.range([this._height, 0]);

        d3.select(this.$.svg).attr('viewBox', '0 0 ' + this._parent.offsetWidth + ' ' + this._parent.offsetHeight);


        d3.select(this.$.menubutton).attr('x', (this.margin.left + this._width + 1)+'px')
                                    .attr('y', (this.margin.top)+'px')
                                    .attr('height', this.brushWidth+'px')
                                    .attr('width', this.brushWidth+'px')
                                    .select('rect')
                                    .attr('height', this.brushWidth+'px')
                                    .attr('width', this.brushWidth+'px');
        d3.select(this.$.menubutton).select('g')
                                    .attr('transform', 'translate(8,0)')
                                    .select('svg')
                                    .attr('width', (this.brushWidth - 16)+'px' );
        d3.select(this.$.menu).attr('style', 'right:'+(this.margin.right+this.brushWidth+2)+'px;top:'+(this.margin.top+this.brushWidth+2)+'px');

        this._chart.attr('transform', 'translate(' + this.margin.left + ',' + (this.brushWidth + this.margin.top) + ')');

        // Limiting Projection to Margin
        this._chart.selectAll('clipPath#clip rect')
                   .attr('width', this._width)
                   .attr('height', this._height);

        this._chart.select('rect.plot')
                  .attr('width', this._width)
                  .attr('height', this._height);

        this._chart.select('g.x.axis')
                  .attr('transform', 'translate(0,' + this._height + ')');

        this._chart.select('g.x.grid')
                  .attr('transform', 'translate(0,' + this._height + ')')
                  .call(this._createTimeAxis(this._x, 'bottom')
                            .tickSize(-this._height, 0, 0)
                            .tickFormat(''));
        this._chart.select('g.y.grid')
                  .call(this._createNumberAxis(this._y, 'left')
                            .tickSize(-this._width, 0, 0)
                            .tickFormat(''));

        this._focusX.attr('y2', this._height);
        this._focusY.attr('x2', this._width);

        this._brushX.attr('transform', 'translate(' + this.margin.left + ',' + (this.margin.top + this.brushWidth)+ ')');
        this._brushX.select('rect.background')
                      .attr('width', this._width)
                      .attr('height', this.brushWidth)
                      .attr('transform', 'translate(0,-' + this.brushWidth + ')');
        // this._brushGridX.tickSize(this.brushWidth, 0, 0);
        // this._brushX.select('.grid')
        //             .attr('transform', 'translate(0,' + (0) + ')');
        this._brushX.select('.brush')
                    .selectAll('rect')
                      .attr('y',  -this.brushWidth)
                      .attr('width', this._width)
                      .attr('height', this.brushWidth);

        this._brushY.attr('transform', 'translate(' + (this.margin.left + this._width) + ',' + (this.margin.top + this.brushWidth) + ')');
        this._brushY.select('rect.background')
                      .attr('width', this.brushWidth)
                      .attr('height', this._height)
                      .attr('transform', 'translate(0,0)');
        // this._brushGridY.tickSize(this.brushWidth, 0, 0);
        // this._brushY.select('.grid')
        //             .attr('transform', 'translate(' + (0) + ',0)');
        this._brushY.select('.brush')
                    .selectAll('rect')
                      .attr('x',  0)
                      .attr('width', this.brushWidth)
                      .attr('height', this._height);

        d3.select(this.$.svg).selectAll('g.tick,g.tick line,g.tick text,g path.domain,rect,g.axis,text')
                             .classed('style-scope', true)
                             .classed('chart-element', true);
      },

      _createNumberScale: function(option, y) {
        var scale;
        switch (option) {
          case 'ln':
            scale = d3.scale.log().base(Math.E); break;
          case 'log':
            scale = d3.scale.log(); break;
          default:
            scale = d3.scale.linear();
        }
        return scale;
      },

      _createTimeAxis: function(scale, orient) {
        return d3.svg.axis()
                 .scale(scale)
                 .orient(orient)
                 .ticks(this.ticks)
                 .tickFormat(this.timeFormat);
      },

      _createNumberAxis: function(scale, orient) {
        return d3.svg.axis()
                 .scale(scale)
                 .orient(orient)
                 .ticks(this.ticks)
                //  .tickFormat(this.numberFormat);
      },

      redraw: function () {
        this.debounce('redraw', function() { this._redraw() }, 100);
      },

      _redraw: function () {
        this._chart.select('.x.axis').transition(100).call(this._xAxis);
        this._chart.select('.y.axis').transition(100).call(this._yAxis);
        this._chart.select('.x.grid').transition(100)
                   .call(this._createTimeAxis(this._x, 'bottom')
                             .tickSize(-this._height, 0, 0)
                             .tickFormat(''));
        this._chart.select('.y.grid').transition(100)
                   .call(this._createNumberAxis(this._y, 'left')
                             .tickSize(-this._width, 0, 0)
                             .tickFormat(''));
        this._brushBehaviorX.extent(this._brushBehaviorX.extent());
        this._brushX.select('.axis').transition(100).call(this._brushAxisX);
        // this._brushX.select('.grid').transition(100).call(this._brushGridX);
        this._brushX.select('.brush').transition(100).call(this._brushBehaviorX)
        this._brushBehaviorY.extent(this._brushBehaviorY.extent());
        this._brushY.select('.axis').transition(100).call(this._brushAxisY);
        // this._brushY.select('.grid').transition(100).call(this._brushGridY);
        this._brushY.select('.brush').transition(100).call(this._brushBehaviorY)
        d3.select(this.$.svg).selectAll('g.tick,g.tick line,g.tick text,g path.domain,rect,g.axis,text')
                             .classed('style-scope', true)
                             .classed('chart-element', true);
        this._graphs.forEach(function(g) { g.redraw(); });
      },

      _brushedX: function() {
        this.isClamping = (this.clamp === true && this._brushBehaviorX.empty() === false && this._x2.domain()[1] - this._brushBehaviorX.extent()[1] < this.clampExtend);
        if (this.isClamping) {
          this._brushBehaviorX.extent( [ this._brushBehaviorX.extent()[0], this._x2.domain()[1] ] );
          this._brushX.select('rect.extent').classed('clamp', true);
        }
        else
          this._brushX.select('rect.extent').classed('clamp', false);
        this._x.domain(this._brushBehaviorX.empty() ? this._x2.domain() : this._brushBehaviorX.extent());
        this.redraw();
      },
      _brushedY: function() {
        this._y.domain(this._brushBehaviorY.empty() ? this._y2.domain() : this._brushBehaviorY.extent());
        this.redraw();
      },

      setAllDomains: function () {
        this.debounce('domains', function() { this._setAllDomains() }, 100);
      },

      setAllDomains: function () {
        var graphs = this._graphs;
        var domainX, domainY = [0, 0], domainTmp, v;
        domainX  = [ d3.min(graphs,function(g){ return d3.min(g.values,function(v){ return v.x; }) }) ,
                     d3.max(graphs,function(g){ return d3.max(g.values,function(v){ return v.x; }) }) ];
        domainTmp  = [ d3.min(graphs,function(g){ return d3.min(g.values,function(v){ return v.y; }) }),
                     d3.max(graphs,function(g){ return d3.max(g.values,function(v){ return v.y;})}) ];

        v = (domainTmp[0]).toExponential().split('e');
        domainY[0] = (Math.floor(v[0])) * Math.pow(10,parseInt(v[1],10));
        v = (domainTmp[1]).toExponential().split('e');
        domainY[1] = (Math.ceil(v[0]) + 1) * Math.pow(10,parseInt(v[1],10));

        this._x2.domain(domainX);
        this._y2.domain(domainY);
        if (!this._brushBehaviorX.empty()) {
          domainTmp = this._brushBehaviorX.extent();
          if ( domainTmp[0] <= domainX[0] ) {
            this._brushBehaviorX.extent( [domainX[0], domainTmp[1]] );
            domainTmp = this._brushBehaviorX.extent();
            if (this.isClamping === true || domainTmp[1] <= domainX[0]) {
              this._brushBehaviorX.clear();
            }
          }
          else if (this.isClamping === true) {
            this._brushBehaviorX.extent( [domainTmp[0], domainX[1]] );
          }
          domainX = this._brushBehaviorX.extent();

        }
        if (!this._brushBehaviorY.empty()) {
          domainY = this._brushBehaviorY.extent();
        }
        this._x.domain(domainX);
        this._y.domain(domainY);
        this.redraw();
      },

      _showFocus: function() {
        d3.select('g#focus').style('opacity', 1);
      },
      _drawFocus: function() {
        this._focusX.attr('transform', 'translate(' + (d3.event.layerX - this.margin.left) + ',0)');
        this._focusY.attr('transform', 'translate(0,' + (d3.event.layerY - this.margin.top - this.brushWidth) + ')');
      },
      _hideFocus: function() {
        d3.select('g#focus').transition(2000).style('opacity', 0);
      },
      toggleMenu: function() {
        if (this.$.menu.hasAttribute('hidden')) {
          this.$.menu.removeAttribute('hidden');
        }
        else {
          this.$.menu.setAttribute('hidden', true);
        }
      },
      changeInterpolation: function(newValue, oldValue) {
        if (oldValue === undefined) return;
        this._graphs.forEach(
          function(g) {
            if (g._lineFunction)
              g._lineFunction.interpolate(newValue);
          });
        this.redraw();
      },
      changeScale: function(newValue, oldValue) {
        if (oldValue === undefined) return;
        this._buildLayout();
        this._sizeLayout();
        this.redraw();
      }
    });

  </script>

</dom-module>

<!-- Dependent to be content of diagram-container -->
<!-- Using d3.js-library -->

<link rel='import' href='../behaviors/element-behavior.html'>
<dom-module id='graph-element'>

  <script>

    DiagramGraph = Polymer({
      is: 'graph-element',

      behaviors: [ElementBehavior],

      properties: {
        values: {
          type: Array,
          value: function() { return []; }
        },
        color: {
          type: String,
          value: '',
          observer: 'setColor'
        },
        dots: {
          type: Boolean,
          value: false,
          observer: '_dotsChanged'
        },
        line: {
          type: Boolean,
          value: true,
          observer: '_dotsChanged'
        },
        dotRadius: {
          type: Number,
          value: 2.5,
          observer: '_dotRadiusChanged'
        },
        lineWidth: {
          type: Number,
          value: 1.5,
          observer: '_lineWidthChanged'
        },
        _node: {},
        _line: {},
        _dots: {},
        _lineFunction: {}
      },

      get chartElement () {
        if (this.parentElement.nodeName !== 'CHART-ELEMENT') {
          console.warn(this.id, 'Graph is not attached to a container');
          return;
        }
        else return this.parentElement;
      },

      get _self () {
        return this;
      },

      get _values () {
        return this.values;
      },

      attached: function () {
        if (this.chartElement.nodeName !== 'CHART-ELEMENT') {
          console.warn(this.id, 'Graph is not attached to a container');
          return;
        }
        if (!this.color) this.setColor();
        // clippath for this graph
        this._node = this.chartElement._chart.append('g')
                                             .attr('clip-path', 'url(#clip)')
                                             .attr('id', this.id)
                                             .attr('label', this.label);

        var self = this;
        // node of line
        this._lineFunction = d3.svg.line().interpolate('cardinal')
                               .x( function (d) {
                                 return self.chartElement._x(d.x);
                               })
                               .y( function (d) {
                                 return self.chartElement._y(d.y);
                               });
        this._line = this._node.append("g")
                                .append('svg:path')
                                .attr('hidden', this.line ? null : true).attr('class', 'line')
                                .attr('fill', 'none').attr('stroke', this.color)
                                .attr('stroke-width', this.lineWidth)                              .datum([])
                                .attr("d", this._lineFunction);
        // group of dots
        this._dots = this._node.append("g")
                               .attr("class", "dots")
                               .attr("hidden", this.dots ? null : true);
        // set Values
        if (this.values.length > 0) this.setValues(this.values);
      },

      factoryImpl: function (element, bubbles) {
        this.setElement(element);
        if (bubbles === true)
          this.bubbles = true;
      },

      redraw: function () {
        var dots = this._dots.selectAll('circle.dot')
                             .data(this.values);
        // update current dots
        dots.attr('cx', (function(d,i) {
              return this.chartElement._x(d.x)}).bind(this._self))
            .attr('cy', (function(d,i) {
              return this.chartElement._y(d.y)}).bind(this._self))
        // enter new dots
        dots.enter()
            .append('circle')
              .attr('class', 'dot')
              .attr('r', this.dotRadius).attr('fill', '#FFF')
              .attr('stroke', this.color).attr('stroke-width', this.lineWidth)
              .attr('cx', (function(d,i) {
                return this.chartElement._x(d.x)}).bind(this._self))
              .attr('cy', (function(d,i) {
                return this.chartElement._y(d.y)}).bind(this._self));
        //  remove old dots
        dots.exit()
            .remove();
        // updata line
        this._line.attr('d', this._lineFunction(this.values));
      },

      setValues: function (values, newestDataLast) {
        this.set('values', values);
        this._updateView(undefined, {});
      },

      unshiftValues: function(value) {
        if (this.values.length === 0) {
          this.setValues([value]);
          return;
        }
        this.unshift('values', value);
        this._updateView(value);
      },

      _updateView: function (value, splices) {
        this._setDomains(value);
        this.chartElement.redraw();
      },

      _setDomains: function(value) {
        var domainX, domainY, domainAllX, domainBrushX;
        // new values
        if (value !== undefined) {
          domainY = this.chartElement._y.domain();
          if (this.chartElement._brush.empty()) {
            domainX = this.chartElement._x.domain();
            domainX[0] = (value.x < domainX[0]) ? value.x : domainX[0];
            domainX[1] = (value.x > domainX[1]) ? value.x : domainX[1];

            domainY[0] = (value.y < domainY[0]) ? value.y - (domainY[1] - value.y) * 0.2: domainY[0];
            domainY[1] = (value.y > domainY[1]) ? value.y + (value.y - domainY[0]) * 0.2: domainY[1];

            this.chartElement._x2.domain(domainX);
          }
          else {
            domainAllX = this.chartElement._x2.domain();
            domainAllX[0] = (value.x < domainAllX[0]) ? value.x : domainAllX[0];
            domainAllX[1] = (value.x > domainAllX[1]) ? value.x : domainAllX[1];
            this.chartElement._x2.domain(domainAllX);

            if (this.chartElement.isClamping === true) {
              domainBrushX = this.chartElement._brush.extent();
              this.chartElement._brush.extent( [domainBrushX[0], domainAllX[1]] );
            }
            domainX = this.chartElement._brush.extent();
          }
        }
        // reducing values
        else {
          domainX  = [ d3.min(this.values, function(v) { return v.x; }),
                       d3.max(this.values, function(v) { return v.x; }) ];
          this.chartElement._x2.domain(domainX);
          if (this.chartElement._brush.empty()) {
            domainY  = [ d3.min(this.values, function(v) { return v.y; }),
                         d3.max(this.values, function(v) { return v.y; }) ];
            domainY = [ domainY[0] - (domainY[1] - domainY[0]) * 0.2,
                        domainY[1] + (domainY[1] - domainY[0]) * 0.2 ];
          }
          else {
            domainBrushX = this.chartElement._brush.extent();
            if ( domainBrushX[0] <= domainX[0] ) {
              this.chartElement._brush.extent( [domainX[0], domainBrushX[1]] );
              domainBrushX = this.chartElement._brush.extent();
              if (this.chartElement.isClamping === true || domainBrushX[1] <= domainX[0]) {
                this.chartElement._brush.clear();
              }

            }
            else if (this.chartElement.isClamping === true) {
              this.chartElement._brush.extent( [domainBrushX[0], domainX[1]] );
            }
            domainX = this.chartElement._brush.extent();
            domainY  = [ d3.min(this.values, function(v) { if (v.x > domainX[0]) return v.y; }),
                         d3.max(this.values, function(v) { if (v.x < domainX[1]) return v.y; }) ];
            domainY = [ domainY[0] - (domainY[1] - domainY[0]) * 0.2,
                        domainY[1] + (domainY[1] - domainY[0]) * 0.2 ];
          }
        }
        this.chartElement._x.domain(domainX);
        this.chartElement._y.domain(domainY);
      },

      setColor: function(color) {
        // random color if color is not set
        if (!color) {
          color = '#';
          var perm = ['2C', 'F5'];
          perm.push(Math.floor(Math.random()*256).toString(16));
          for (var i = 3; i > 0; i--) {
            var pos = Math.floor(Math.random()*i);
            color += ((perm[pos].length === 1) ? '0' : '') + perm[pos];
            perm.splice(pos, 1);
          }
          this.color = color;
        }
        if (this._node) {
          if (this._line) this._line.attr('stroke', this.color);
          if (this._dots)
            this._dots.selectAll('circle.dot')
                      .attr('stroke', this.color);
        }
      },

      _dotsChanged: function(dots) {
        if (this._node && this._dots) {
          this._dots.attr('hidden', dots ? null : true);
        }
      },

      _lineChanged: function(line) {
        if (this._node && this._line) {
          this._line.attr('hidden', line ? null : true);
        }
      },

      _dotRadiusChanged: function(dotRadius) {
        if (this._node && this._dots) {
          this._dots.selectAll('circle.dot').attr('r', dotRadius);
        }
      },

      _lineWidthChanged: function(lineWidth) {
        if (this._node) {
          if (this._line) this._line.attr('stroke-width', this.lineWidth);
          if (this._dots)
            this._dots.selectAll('circle.dot')
                      .attr('stroke-width', this.lineWidth);
        }
      }
    });

  </script>

</dom-module>

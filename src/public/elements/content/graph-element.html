<!-- Dependent to be content of diagram-container -->
<!-- Using d3.js-library -->

<link rel='import' href='../behaviors/element-behavior.html'>
<dom-module id='graph-element'>

  <script>

    DiagramGraph = Polymer({
      is: 'graph-element',

      behaviors: [ElementBehavior],

      properties: {
        values: {
          type: Array,
          value: function() { return []; }
        },
        color: {
          type: String,
          value: '',
          observer: 'setColor'
        },
        dots: {
          type: Boolean,
          value: true,
          observer: '_dotsChanged'
        },
        line: {
          type: Boolean,
          value: true,
          observer: '_dotsChanged'
        },
        dotRadius: {
          type: Number,
          value: 2.5,
          observer: '_dotRadiusChanged'
        },
        lineWidth: {
          type: Number,
          value: 1.5,
          observer: '_lineWidthChanged'
        },
        _node: {},
        _line: {},
        _dots: {},
        _lineFunction: {}
      },

      get chartElement () {
        if (this.parentElement.nodeName !== 'CHART-ELEMENT') {
          console.warn(this.id, 'Graph is not attached to a container');
          return;
        }
        else return this.parentElement;
      },

      get _self () {
        return this;
      },

      get _values () {
        return this.values;
      },

      attached: function () {
        if (this.chartElement.nodeName !== 'CHART-ELEMENT') {
          console.warn(this.id, 'Graph is not attached to a container');
          return;
        }
        if (!this.color) this.setColor();
        // clippath for this graph
        this._node = this.chartElement._chart.select('g#graphs')
                                             .append('svg:g')
                                             .attr('clip-path', 'url(#clip)')
                                             .attr('id', this.id)
                                             .attr('label', this.label);

        var self = this;
        // node of line
        this._lineFunction = d3.svg.line().interpolate('cardinal')
                               .x( function (d) {
                                 return self.chartElement._x(d.x);
                               })
                               .y( function (d) {
                                 return self.chartElement._y(d.y);
                               });
        this._line = this._node.append('svg:path')
                               .attr("class", "line")
                               .attr('hidden', this.line ? null : true)
                               .attr('fill', 'none').attr('stroke', this.color)
                               .attr('stroke-width', this.lineWidth)                              .datum([])
                               .attr("d", this._lineFunction);
        // group of dots
        this._dots = this._node.append("svg:g")
                               .attr("class", "dots")
                               .attr("hidden", this.dots ? null : true);

        Polymer.dom.flush();
        // set Values
        if (this.values.length > 0) this.setValues(this.values);
      },

      factoryImpl: function (element, bubbles) {
        this.setElement(element);
        if (bubbles === true)
          this.bubbles = true;
      },

      redraw: function () {
        var dots = this._dots.selectAll('circle.dot')
                             .data(this.values);
        // update current dots
        dots.attr('cx', (function(d,i) {
              return this.chartElement._x(d.x)}).bind(this._self))
            .attr('cy', (function(d,i) {
              return this.chartElement._y(d.y)}).bind(this._self))
        // enter new dots
        dots.enter()
            .append('circle')
              .attr('class', 'dot')
              .attr('r', this.dotRadius).attr('fill', '#FFF')
              .attr('stroke', this.color).attr('stroke-width', this.lineWidth)
              .attr('cx', (function(d,i) {
                return this.chartElement._x(d.x)}).bind(this._self))
              .attr('cy', (function(d,i) {
                return this.chartElement._y(d.y)}).bind(this._self));
        //  remove old dots
        dots.exit()
            .remove();
        // updata line
        this._line.attr('d', this._lineFunction(this.values));
      },

      setValues: function (values, newestDataLast) {
        this.set('values', values);
        this._updateView(undefined, {});
      },

      unshiftValues: function(value) {
        if (this.values.length === 0) {
          this.setValues([value]);
          return;
        }
        this.unshift('values', value);
        this._updateView(value);
      },

      _updateView: function (value, splices) {
        if (value !== undefined) {
          this._setDomains(value);
          this.chartElement.redraw();
        }
        else
          this.chartElement.setAllDomains();

      },

      _setDomains: function(value, splice) {
        var domainX, domainY = [0 ,0], domainTmp;
        // new values
        if (this.chartElement._brushBehaviorX.empty()) {
          domainX = this.chartElement._x.domain();
          domainX[0] = (value.x < domainX[0]) ? value.x : domainX[0];
          domainX[1] = (value.x > domainX[1]) ? value.x : domainX[1];
          this.chartElement._x2.domain(domainX);
        }
        else {
          domainX = this.chartElement._x2.domain();
          domainX[0] = (value.x < domainX[0]) ? value.x : domainX[0];
          domainX[1] = (value.x > domainX[1]) ? value.x : domainX[1];
          this.chartElement._x2.domain(domainX);
          if (this.chartElement.isClamping === true) {
            domainTmp = this.chartElement._brushBehaviorX.extent();
            this.chartElement._brushBehaviorX.extent( [domainTmp[0], domainX[1]] );
          }
          domainX = this.chartElement._brushBehaviorX.extent();
        }
        if (this.chartElement._brushBehaviorY.empty()) {
          domainTmp = this.chartElement._y.domain();
          domainY[0] = (value.y<domainTmp[0]) ? value.y-(domainTmp[1]-value.y)*0.2: domainTmp[0];
          domainY[1] = (value.y>domainTmp[1]) ? value.y+(value.y-domainTmp[0])*0.2: domainTmp[1];
          this.chartElement._y2.domain(domainY);
        }
        else {
          domainTmp = this.chartElement._y2.domain();
          domainY[0] = (value.y<domainTmp[0]) ? value.y-(domainTmp[1]-value.y)*0.2: domainTmp[0];
          domainY[1] = (value.y>domainTmp[1]) ? value.y+(value.y-domainTmp[0])*0.2: domainTmp[1];
          this.chartElement._y2.domain(domainY);
          domainY = this.chartElement._brushBehaviorY.extent();
        }
        this.chartElement._x.domain(domainX);
        this.chartElement._y.domain(domainY);
      },

      setColor: function(color) {
        // random color if color is not set
        if (!color) {
          color = '#';
          var perm = ['2C', 'F5'];
          perm.push(Math.floor(Math.random()*256).toString(16));
          for (var i = 3; i > 0; i--) {
            var pos = Math.floor(Math.random()*i);
            color += ((perm[pos].length === 1) ? '0' : '') + perm[pos];
            perm.splice(pos, 1);
          }
          this.color = color;
        }
        if (this._node) {
          if (this._line) this._line.attr('stroke', this.color);
          if (this._dots)
            this._dots.selectAll('circle.dot')
                      .attr('stroke', this.color);
        }
      },

      _dotsChanged: function(dots) {
        if (this._node && this._dots) {
          this._dots.attr('hidden', dots ? null : true);
        }
      },

      _lineChanged: function(line) {
        if (this._node && this._line) {
          this._line.attr('hidden', line ? null : true);
        }
      },

      _dotRadiusChanged: function(dotRadius) {
        if (this._node && this._dots) {
          this._dots.selectAll('circle.dot').attr('r', dotRadius);
        }
      },

      _lineWidthChanged: function(lineWidth) {
        if (this._node) {
          if (this._line) this._line.attr('stroke-width', this.lineWidth);
          if (this._dots)
            this._dots.selectAll('circle.dot')
                      .attr('stroke-width', this.lineWidth);
        }
      }
    });

  </script>

</dom-module>

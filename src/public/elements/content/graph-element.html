<!-- Dependent to be content of diagram-container -->
<!-- Using d3.js-library -->

<link rel='import' href='../behaviors/element-behavior.html'>
<dom-module id='graph-element'>

  <script>

    DiagramGraph = Polymer({
      is: 'graph-element',

      behaviors: [ElementBehavior],

      properties: {
        values: {
          type: Array,
          value: function() { return []; }
        },
        color: {
          type: String,
          value: '',
          observer: 'setColor'
        },
        noDots: {
          type: Boolean,
          value: false,
          observer: '_dotsChanged'
        },
        noLine: {
          type: Boolean,
          value: false,
          observer: '_lineChanged'
        },
        dotRadius: {
          type: Number,
          value: 2.5,
          observer: '_dotRadiusChanged'
        },
        lineWidth: {
          type: Number,
          value: 1.5,
          observer: '_lineWidthChanged'
        },
        _node: Object,
        _line: Object,
        _dots: Object,
        _lineFunction: Object
      },

      get chartElement () {
        if (this.parentElement.nodeName !== 'CHART-ELEMENT') {
          console.warn(this.id, 'Graph is not attached to a container');
          return;
        }
        else return this.parentElement;
      },

      get _self () {
        return this;
      },

      get _values () {
        return this.values;
      },

      attached: function () {
        if (this.chartElement.nodeName !== 'CHART-ELEMENT') {
          console.warn(this.id, 'Graph is not attached to a container');
          return;
        }
        if (!this.color) this.setColor();
        // clippath for this graph
        this._node = this.chartElement._chart.select('g#graphs')
                                             .append('svg:g')
                                             .attr('clip-path', 'url(#clip)')
                                             .attr('id', this.id)
                                             .attr('label', this.label);

        var self = this;
        // node of line
        this._lineFunction = d3.line()
                               .x( function (d) { return self.chartElement._x(d.x); })
                               .y( function (d) { return self.chartElement._y(d.y); });
                              //  .curveCatmullRom(1);
        this._line = this._node.append('svg:path')
                               .attr("class", "line")
                               .attr('hidden', this.noLine ? true : null)
                               .attr('fill', 'none').attr('stroke', this.color)
                               .attr('stroke-width', this.lineWidth)                              .datum([])
                               .attr("d", this._lineFunction);
        // group of dots
        this._dots = this._node.append("svg:g")
                               .attr("class", "dots")
                               .attr("hidden", this.noDots ? true : null);

        Polymer.dom.flush();
        // set Values
        if (this.values.length > 0) this.setValues(this.values);
      },

      factoryImpl: function (element, bubbles) {
        this.setElement(element);
        if (bubbles === true)
          this.bubbles = true;
      },

      redraw: function () {
        if (this._hidden === true) return;

        var dots = this._dots.selectAll('circle.dot')
                             .data(this.values);
        // update current dots
        dots.attr('cx', (function(d,i) {
              return this.chartElement._x(d.x)}).bind(this._self))
            .attr('cy', (function(d,i) {
              if (isNaN(this.chartElement._y(d.y)))
                console.log(d.y, this.chartElement._y.domain());
              return this.chartElement._y(d.y)}).bind(this._self))
        // enter new dots
        dots.enter()
            .append('circle')
              .attr('class', 'dot')
              .attr('r', this.dotRadius).attr('fill', '#FFF')
              .attr('stroke', this.color).attr('stroke-width', this.lineWidth)
              .attr('cx', (function(d,i) {
                return this.chartElement._x(d.x)}).bind(this._self))
              .attr('cy', (function(d,i) {
                return this.chartElement._y(d.y)}).bind(this._self))
              .on('mouseenter', (function(d) {
                this.chartElement._updateInfo(d)
              }).bind(this._self));
              // .on('mouseleave', this.chartElement._hideFocus.bind(this._self));
        //  remove old dots
        dots.exit()
            .remove();
        // updata line
        this._line.attr('d', this._lineFunction(this.values));
      },

      setValues: function (values, newestDataLast) {
        this.set('values', values);
        this._updateView(undefined, Object);
      },

      unshiftValues: function(value) {
        if (this.values.length === 0) {
          this.setValues([value]);
          return;
        }
        this.unshift('values', value);
        this._updateView(value);
      },

      _updateView: function (value, splices) {
        if (value !== undefined) {
          if ( value.y < 0 &&
              (this.chartElement.yScale === "ln" ||
               this.chartElement.yScale === "log")) {
            console.warn("ValueError: value in logarithmic scale below 0");
            return;
          }
          this._setDomains(value);
          this.chartElement.redraw();
        }
        else
          this.chartElement.setAllDomains();

      },

      _setDomains: function(value, splice) {
        var domainX, domainY = [0 ,0], domainTmp;
        // new values

        // if (this.chartElement._brushBehaviorX.empty()) {
          domainX = this.chartElement._x.domain();
          domainX[0] = (value.x < domainX[0]) ? value.x : domainX[0];
          domainX[1] = (value.x > domainX[1]) ? value.x : domainX[1];
          this.chartElement._x2.domain(domainX);
        // }
        // else {
        //   domainX = this.chartElement._x2.domain();
        //   domainX[0] = (value.x < domainX[0]) ? value.x : domainX[0];
        //   domainX[1] = (value.x > domainX[1]) ? value.x : domainX[1];
        //   this.chartElement._x2.domain(domainX);
        //   if (this.chartElement.isClamping === true) {
        //     domainTmp = this.chartElement._brushBehaviorX.extent();
        //     this.chartElement._brushBehaviorX.extent( [domainTmp[0], domainX[1]] );
        //   }
        //   domainX = this.chartElement._brushBehaviorX.extent();
        // }
        // if (this.chartElement._brushBehaviorY.empty())
          domainTmp = this.chartElement._y.domain();
        // else
        //   domainTmp = this.chartElement._y2.domain();

        if (value.y < domainTmp[0]) {
          var v = (value.y).toExponential().split('e');
          domainY[0] = (Math.floor(v[0])) * Math.pow(10,parseInt(v[1],10));
        }
        else domainY[0] = domainTmp[0];
        if (value.y > domainTmp[1]) {
          var v = (value.y).toExponential().split('e');
          domainY[1] = (Math.ceil(v[0]) + 1) * Math.pow(10,parseInt(v[1],10));
        }
        else domainY[1] = domainTmp[1];

        this.chartElement._x.domain(domainX);
        this.chartElement._y.domain(domainY);
        // this.chartElement._y2.domain(domainY);
      },

      setColor: function(color) {
        // random color if color is not set
        if (!color) {
          color = '#';
          var perm = ['2C', 'F5'];
          perm.push(Math.floor(Math.random()*256).toString(16));
          for (var i = 3; i > 0; i--) {
            var pos = Math.floor(Math.random()*i);
            color += ((perm[pos].length === 1) ? '0' : '') + perm[pos];
            perm.splice(pos, 1);
          }
          this.color = color;
        }
        if (this._node) {
          if (this._line) this._line.attr('stroke', this.color);
          if (this._dots)
            this._dots.selectAll('circle.dot')
                      .attr('stroke', this.color);
        }
      },

      _dotsChanged: function() {
        if (this._node && this._dots) {
          this._dots.attr('hidden', this.noDots ? true : null);
        }
      },

      _lineChanged: function() {
        if (this._node && this._line) {
          this._line.attr('hidden', this.noLine ? true : null);
        }
      },

      _dotRadiusChanged: function(dotRadius) {
        if (this._node && this._dots) {
          this._dots.selectAll('circle.dot').attr('r', dotRadius);
        }
      },

      _lineWidthChanged: function(lineWidth) {
        if (this._node) {
          if (this._line) this._line.attr('stroke-width', this.lineWidth);
          if (this._dots)
            this._dots.selectAll('circle.dot')
                      .attr('stroke-width', this.lineWidth);
        }
      }
    });

  </script>

</dom-module>

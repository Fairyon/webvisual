<!-- Dependent to be content of diagram-container -->
<!-- Using d3.js-library -->

<link rel='import' href='../behaviors/element-behavior.html'>
<dom-module id='graph-element'>

  <script>

    DiagramGraph = Polymer({
      is: 'graph-element',

      behaviors: [ElementBehavior],

      properties: {
        values: {
          type: Array,
          value: function() { return []; }
        },
        color: {
          type: String,
          value: ''
        },
        dots: {
          type: Boolean,
          value: true
        },
        line: {
          type: Boolean,
          value: true
        },
        dotRadius: {
          type: Number,
          value: 2.5
        },
        lineWidth: {
          type: Number,
          value: 1.5
        },
        _node: {},
        _line: {},
        _dots: {},
        _graph: {}
      },

      get chartElement () {
        if (this.parentElement.nodeName !== 'CHART-ELEMENT') {
          console.warn(this.id, 'Graph is not attached to a container');
          return;
        }
        else {
          return this.parentElement;
        }
      },

      factoryImpl: function (element, bubbles) {
        this.setElement(element);
        if (bubbles === true)
          this.bubbles = true;
      },

      attached: function () {
        if (this.chartElement.nodeName !== 'CHART-ELEMENT') {
          console.warn(this.id, 'Graph is not attached to a container');
          return;
        }
        // if color is not set, set a Random Color
        if (!this.color) {
          this.color = '#';
          var perm = ['2C', 'F5'];
          perm.push(Math.floor(Math.random()*256).toString(16));
          for (var i = 3; i > 0; i--) {
            var pos = Math.floor(Math.random()*i);
            this.color += ((perm[pos].length === 1) ? '0' : '') + perm[pos];
            perm.splice(pos, 1);
          }
        }
        this._node = this.chartElement._chart.append('g')
                                             .attr('clip-path', 'url(#clip)')
                                             .attr('id', this.id)
                                             .attr('label', this.label);

        var self = this;
        this._line = d3.svg.line().interpolate('cardinal')
                           .x( function (d) {
                             return self.chartElement._x(d.x);
                           })
                           .y( function (d) {
                             return self.chartElement._y(d.y);
                           });
        this._node.append('svg:path')
                  .datum([])
                  .attr('class', 'line')
                  .attr('stroke', this.color)
                  .attr('stroke-width', this.lineWidth)
                  .attr('fill', 'none');

        if (this.values.length > 0)
          this.setValues(this.values);
      },

      redraw: function () {
        this._dots = this._node.selectAll('.dot')
                               .data(this.values);
        this._dots.enter()
                  .append('svg:circle')
                  .attr('class', 'dot')
                  .attr('r', this.dotRadius)
                  .attr('fill', '#FFF')
                  .attr('stroke', this.color)
                  .attr('stroke-width', this.lineWidth);
        // this._dots.exit().remove();
        this._dots.attr('cx', (function(d,i) {return this._x(d.x)}).bind(this.chartElement))
                  .attr('cy', (function(d,i) {return this._y(d.y)}).bind(this.chartElement))
                  .attr("transform", null)
                .transition(500)
                  .attr("transform", "translate(" + this.chartElement._x(this.values[this.values.length-1].x) + ",0)");

        this._node.select('.line')
                  .attr('d', this._line(this.values))
                  .attr("transform", null)
                .transition(500)
                  .attr("transform", "translate(" + this.chartElement._x(this.values[this.values.length-1].x) + ",0)");
                  // .attr("transform", "translate(" + this.chartElement._x(-1000) + ")");
      },

      setValues: function (values, newestDataLast) {
        this.set('values', values);

        // this._dots = this._node.selectAll('.dot')
        //                        .data(this.values);
        // this._dots.enter()
        //           .append('svg:circle')
        //           .attr('class', 'dot')
        //           .attr('r', this.dotRadius)
        //           .attr('fill', '#FFF')
        //           .attr('stroke', this.color)
        //           .attr('stroke-width', this.lineWidth);
        // this._dots.exit().remove();

        this._node.select(".line")   // change the line
                  .attr("d", this._line(values));

        this._updateView(undefined, {});
      },

      unshiftValues: function(value) {
        if (this.values.length === 0) {
          this.setValues([value]);
          return;
        }
        this.unshift('values', value);
        this._updateView(value);
      },

      _updateView: function (value, splices) {
        var domainX, domainY, domainBrushX;
        if (value !== undefined) {
          if (this.chartElement._brush.empty()) {
            domainX = this.chartElement._x.domain();
            domainY = this.chartElement._y.domain();
            domainX[0] = (value.x < domainX[0]) ? value.x : domainX[0];
            domainX[1] = (value.x > domainX[1]) ? value.x : domainX[1];
            domainY[0] = (value.y < domainY[0]) ? value.y * 0.95 : domainY[0];
            domainY[1] = (value.y > domainY[1]) ? value.y * 1.05 : domainY[1];
            this.chartElement._x.domain(domainX);
            this.chartElement._y.domain(domainY);
            this.chartElement._x2.domain(domainX);
          }
          else {
            domainX = [0, 0];
            domainBrushX = this.chartElement._x2.domain();
            domainX[0] = (value.x < domainBrushX[0]) ? value.x : domainBrushX[0];
            domainX[1] = (value.x > domainBrushX[1]) ? value.x : domainBrushX[1];
            this.chartElement._x2.domain(domainX);
          }
        }
        if (splices !== undefined) {
          if (this.chartElement._brush.empty()) {
            var domainX  = [ d3.min(this.values, function(v) { return v.x; }),
                             d3.max(this.values, function(v) { return v.x; }) ];
            var domainY  = [ d3.min(this.values, function(v) { return v.y; }) * 0.95,
                             d3.max(this.values, function(v) { return v.y; }) * 1.05 ];

            this.chartElement._x.domain(domainX);
            this.chartElement._y.domain(domainY);
            this.chartElement._x2.domain(domainX);
          }
          else {

          }
        }
        // this.redraw();
        this.chartElement.redraw();
        // this.chartElement._d3Zoom = d3.behavior.zoom()
        //                           .x(this.chartElement._x)
        //                           .y(this.chartElement._x)
        //                           .on('zoom', this.chartElement._zoom.bind(this.chartElement));
      }
    });

  </script>

</dom-module>

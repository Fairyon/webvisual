<dom-module id="data-socket-repeater">

  <script>
  HTMLImports.whenReady(function() {
    Polymer({
      is: 'data-socket-repeater',

      properties: {
          socket: {
            type: String,
            value: "/data",
            notify: true
          },
          data: {
            type: Array,
            value: function() { return []; },
            notify: true,
            readOnly: true
          },
          groups: {
            type: Object,
            value: function() { return {}; },
            notify: true
          },
          keys: {
            type: Array,
            value: function() { return ["kind","method","room","roomNr","all"]; }
          },
          lastMessage: {
            type: Date,
            value: 0,
            notify: true
          },
          lastMistake: {
            type: Date,
            value: 0,
            notify: true
          },
          lastError: {
            type: Date,
            value: 0,
            notify: true
          },
          maxTotalLines: {
            type: Number,
            observer: 'maxTotalLinesChanged',
            value: 10,
            notify: true
          },
          doAppend: {
            type: Boolean,
            value: false,
            notify: true
          },
          interval: {
            type: Number,
            value: 5,
            notify: true
          }
      },

      ready: function(){
        // TODO: sort the data points?
        var self = this;
        var dataSocket = io.connect('https://'+window.location.host+this.socket, {secure: true});
        // Receiving the FIRST Data
        dataSocket.on('first', function(message) {
          if(message === undefined || message.content === undefined) return; // Check the Existence

          self.set("lastMessage", new Date(message.time));
          self.setLanguage(message.language);
          self.setKeys(message.groupingKeys);

          var overhead, messageLength, messageContent;
          // for Polymer (to notice Array change) special treatment to integrate data
          for (var i in message.content) {
            messageContent = message.content[i];
            messageLength = message.content[i].values.length;

            if (!self.data[i])  // if no reconnection
              self.push("data",{});
            for (var key in messageContent) {
              if(key != "values")
                self.set("data."+i+"."+key, messageContent[key]);
            }
            self.set("data."+i+".values", []);
            overhead = (messageLength > self.maxTotalLines) ? messageLength - self.maxTotalLines : 0;
            for (var j=overhead; j < message.content[i].values.length; j++) {
              self.push("data."+i+".values",message.content[i].values[j]);
            }
          }
          self.grouping(message.content,message.exclusiveGroups);
          self.fire("dataloaded");
        });

        // Receive FURTHER Data
        dataSocket.on('data', function(message) {
          if(message === undefined || message.content === undefined) return; // Check for Existence

          var time = new Date(message.time);

          if (time - self.lastMessage >= self.interval*1000){
            self.set("lastMessage", time);

            var overhead, messageLength;
            if (self.doAppend){
                for (var i=0; i < self.data.length; i++) { // for all messurement-data-alements existing
                  messageLength = message.content[i].values.length;
                  overhead = ((messageLength + self.data[i].values.length) > self.maxTotalLines);
                  for (var j=0; j < messageLength; j++) {
                    self.unshift("data."+i+".values",message.content[i].values[j]);
                    if (overhead) self.pop("data."+i+".values");
                  }
                  self.set("data."+i+".lastExceeds",message.content[i].lastExceeds);
                }
            }
            else {
              for (var i=0; i < self.data.length; i++) {
                while (self.data[i].values.length > 0)
                  self.pop("data."+i+".values");
                overhead = (messageLength > self.maxTotalLines) ? messageLength - self.maxTotalLines : 0;
                for (var j=overhead; j < message.content[i].values.length; j++)
                  self.push("data."+i+".values",message.content[i].values[j]);
                self.set("data."+i+".lastExceeds",message.content[i].lastExceeds);
              }
            }
          }
        });

        //*** Wrong Data
        dataSocket.on('mistake', function() {
          self.set("lastMistake", new Date());
          console.warn("error in data-connection");
        });

        //*** Disconnect
        dataSocket.on('disconnect', function() {
          self.set("lastError", new Date());
          console.warn("client disconnected");
        });

        //*** Disconnect
        dataSocket.on('connect_error', function() {
          self.set("lastError", new Date());
          console.warn("error in connection");
        });

      },

      setLanguage: function(language){
        // TODO: create and set languageset
      },

      setKeys: function(keys){
        for (var i; i < keys.length; i++){
          if(this.keys.indexOf(keys[i]) == -1)
            this.push("keys",keys[i]);
        }
        if (this.keys.indexOf("all") == -1)
          this.push("keys","all");
      },

      grouping: function(content,exclusiveGroups){ // Referencing on group-identities
        if(content){
          var where, innerkey, needToSet;
          if(exclusiveGroups){
            for (var key in exclusiveGroups) {
              this.set("groups."+key,[]);
              for (var i=0; i<exclusiveGroups[key].length; i++){
                this.push("groups."+key,{});
                this.set("groups."+key+"."+i+".group",exclusiveGroups[key][i].group);
                this.set("groups."+key+"."+i+".ids",[]);
                for (var j=0; j<exclusiveGroups[key][i].ids.length; j++){
                  this.push("groups."+key+"."+i+".ids",exclusiveGroups[key][i].ids[j]);
                }
              }
            }
          }
          for (var i in content){
            for (var j=0; j<this.keys.length; j++){
              innerkey = this.keys[j];
              if (!this.groups[innerkey])
                this.set("groups."+innerkey,[]);

              needToSet = true;
              if (exclusiveGroups && exclusiveGroups[innerkey])
                for (var k=0; k<exclusiveGroups[innerkey].length; k++){
                  if(exclusiveGroups[innerkey][k].ids.indexOf(content[i].id) != -1){
                    needToSet = false;
                    break;
                  }
                }

              if(needToSet){
                where = _.findIndex(this.groups[innerkey],{"group": content[i][innerkey]});
                if (where == -1){
                  this.push("groups."+innerkey,{});
                  where = this.groups[innerkey].length-1;
                  this.set("groups."+innerkey+"."+where+".group",content[i][innerkey]);
                  this.set("groups."+innerkey+"."+where+".ids",[]);
                  }
                this.push("groups."+innerkey+"."+where+".ids",content[i].id);
              }
            }
          }
          this.set("groups.all.0.group","all");
        }
      },

      maxTotalLinesChanged: function(newValue, oldValue) {
        var dataLength, overhead;
        if (newValue && this.data && newValue>0)
          for (var i=0; i < this.data.length; i++) {
            dataLength = this.data[i].values.length;
            overhead = (dataLength > newValue) ? dataLength - newValue : 0;
            for (var j = dataLength - overhead; j < dataLength; j++)
              this.pop("data."+i+".values");
          }
        else {
          this.maxTotalLines = oldValue;
        }
      }
    });
  });
  </script>

</dom-module>

<script src="../socket.io/socket.io.js"></script>
<dom-module id="data-socket-repeater">
  <script>
  HTMLImports.whenReady(function() {
    Polymer({
      is: 'data-socket-repeater',

      properties: {
          socketname: {
            type: String,
            value: "/data",
            notify: true
          },
          config: {
            type: Object,
            value: function() {
              return {  "firstPattern": {
                          "query": {},
                          "time": {
                            "from": "2015-10-28 18:30:00"
                          },
                          "limit": -1
                        },
                        "appendPattern": {
                          "query": {},
                          "time": {
                            "from": "2015-01-01"
                          },
                          "limit": -1
                        }};
              },
            notify: true
          },
          data: {
            type: Array,
            value: function() { return []; },
            notify: true,
            readOnly: true
          },
          ids: {
            type: Array,
            value: function() { return []; },
            notify: true,
            readOnly: true
          },
          groups: {
            type: Object,
            value: function() { return {}; },
            notify: true
          },
          keys: {
            type: Array,
            value: function() { return ["kind","method","room","roomNr","all"]; }
          },
          allKeys: {
            type: Array,
            value: function() { return []; }
          },
          status: {
            type: Object,
            value: function() { return {"message": "...",
                                        "time": {
                                          "lastData": 0,
                                          "lastStatus": 0,
                                          "lastMistake": 0,
                                          "lastError": 0
                                        }}; },
            notify: true
          },
          maxTotalLines: {
            type: Number,
            observer: '_maxTotalLinesChanged',
            value: 100,
            notify: true
          },
          maxLines: {
            type: Number,
            value: this.maxTotalLines
          },
          doAppend: {
            type: Boolean,
            value: true,
            notify: true
          },
          newestDataLast: {
            type: Boolean,
            value: true,
            notify: true
          },
          interval: {
            type: Number,
            value: 2000,
            notify: true
          }
      },

      ready: function(){
        this.socket = io.connect('https://'+window.location.host+this.socketname, {secure: true});
        this.set("status.time.lastStatus",new Date()); this.set("status.message", "connecting to "+window.location.host);
        var self = this;
        this.async(function(){
          self.connect(self);
        });
      },

      connect: function() {
        var self = this;
        // Config
        this.socket.on('connect', function() {
          self.set("status.time.lastStatus",new Date()); self.set("status.message", "configuring connection");
          self.set("config.firstPattern.time.from",new Date()-3600000)
          self.socket.emit('clientConfig', self.config);
        });
        // Receiving the FIRST Data
        this.socket.on('first', function(message) {
          self._onData(message);
          console.info("client has established connection to: "+window.location.host);
        });
        // Receive FURTHER Data
        this.socket.on('data', function(message) {
          self._onData(message);
        });
        // TODO: following senseless?
        // Wrong Data
        this.socket.on('mistake', function() {
          self.set("status.time.lastMistake", new Date());
          console.warn("error in data-connection to: "+window.location.host);
        });
        // Disconnect
        this.socket.on('disconnect', function() {
          self.set("status.time.lastError", new Date());
          console.warn("client disconnected to: "+window.location.host);
        });
        // Disconnect
        this.socket.on('connect_error', function() {
          self.set("status.time.lastError", new Date());
          console.warn("error in connection to: "+window.location.host);
        });
      },

      reconnect: function() {
        this.disconnect();
        this.connect();
      },

      disconnect: function() {
        if (this.socket){
          this.socket.disconnect();
          this._init();
        }
      },

      _onData: function(message){
        if(message === undefined) return; // Check for Existence
        if(!this.data || this.data.length === 0)
          this._onFirstData(message);
        else {
          var time = new Date();
          if (time - this.status.time.lastData >= this.interval){ // TODO: Configure it at server
            this.set("status.time.lastData", time);
            for (var i in message.content) { // for all messurement-data-alements existing
              this._setValues(message.content[i],this._getIndex(message.content[i].id));
            }
          }
        }
      },

      _onFirstData: function(message){
        if(message === undefined) return; // Check the Existence
        this._init();
        var time = new Date();
        this.set("status.time.lastStatus",new Date()); this.set("status.message", "processing first data");
        this.set("status.time.lastData", time);

        if (message.groupingKeys) this._setKeys(message.groupingKeys);
        this._setAllKeys(message.unnamedType);

        // for Polymer (to notice Array change) special treatment to integrate data
        var id;
        for (var i in message.content) {
          id = this._getIndex(message.content[i].id);
          this._initDataPoint(message.content[i],id,message.types,message.unnamedType);
          this._setValues(message.content[i],id);
        }
        this.set("status.time.lastStatus",new Date()); this.set("status.message", "grouping elements");
        this._setGroups(message.exclusiveGroups);
        this.fire("dataloaded");
      },

      _getIndex: function(id){
        var check = this.ids.indexOf(id);
        if(check !== -1)
          return check;
        else
          return this._setId(id);
      },

      _setId: function(id){
        return (this.push("ids",id) - 1);
      },

      _setLanguage: function(language){
        // TODO: create and set languageset
      },

      _setKeys: function(keys){
        for (var i; i < keys.length; i++){
          if(this.keys.indexOf(keys[i]) == -1)
            this.push("keys",keys[i]);
        }
        if (this.keys.indexOf("all") == -1)
          this.push("keys","all");
      },

      _setAllKeys: function(unnamedType) {
        var allkeys = _.keys(unnamedType);
        for (var i=0; i < allkeys.length; i++)
          if (this.allKeys.indexOf(allkeys[i]) == -1)
            this.push("allKeys", allkeys[i]);
      },

      _setValues: function(messageContent, i){
        if (!this.doAppend)
          this._initDataPoint(messageContent, i)
        if (this.newestDataLast) {
          for (var j=0; j < messageContent.values.length; j++)
            this.unshift("data."+i+".values",messageContent.values[j]);
        }
        else {
          for (var j=messageContent.values.length-1; j >=0; j--)
            this.unshift("data."+i+".values",messageContent.values[j]);
        }
        if (this.data[i].values.length > this.maxLines)
          this.splice("data."+i+".values",this.maxLines,this.data[i].values.length)
        this.set("data."+i+".lastExceeds",messageContent.lastExceeds);
      },

      _init: function(){
        // this.splice("data",0,this.data.length);
        // this.splice("ids",0,this.ids.length);
      },

      _initDataPoint: function(messageContent,i,types,unnamedType){
        while (this.data.length <= i)
          this.push("data",{});

        if(!this.data[i].values){
          this.set("data."+i+".values",[]);
          this.push("data."+i+".values",{"x":"","y":"","exceeds":null});
        }

        var key;
        for (var j=0; j <= this.allKeys.length; j++) {
          key = this.allKeys[j];
          if(key != "values" && !this.data[i][key]){
            if(types[i] && types[i][key])
              this.set("data."+i+"."+key, types[i][key]);
            else
              this.set("data."+i+"."+key, unnamedType[key]);
          }
        }
      },

      _setGroups: function(exclusiveGroups){ // Referencing on group-identities
        if(this.data){
          this.set("groups",{});
          var where, innerkey, needToSet;
          if(exclusiveGroups){
            for (var key in exclusiveGroups) {
              this.set("groups."+key,[]);
              for (var i=0; i<exclusiveGroups[key].length; i++){
                this.push("groups."+key,{});
                this.set("groups."+key+"."+i+".name",exclusiveGroups[key][i].name);
                this.set("groups."+key+"."+i+".ids",[]);
                for (var j=0; j<exclusiveGroups[key][i].ids.length; j++){
                  this.push("groups."+key+"."+i+".ids",exclusiveGroups[key][i].ids[j]);
                }
              }
            }
          }
          for (var i=0; i < this.data.length; i++){
            for (var j=0; j<this.keys.length; j++){
              innerkey = this.keys[j];
              if (!this.groups[innerkey])
                this.set("groups."+innerkey,[]);

              needToSet = true;
              if (exclusiveGroups && exclusiveGroups[innerkey])
                for (var k=0; k<exclusiveGroups[innerkey].length; k++){
                  if(exclusiveGroups[innerkey][k].ids.indexOf(this.data[i].id) != -1){
                    needToSet = false;
                    break;
                  }
                }

              if(needToSet){
                where = _.findIndex(this.groups[innerkey],{"name": this.data[i][innerkey]});
                if (where == -1){
                  this.push("groups."+innerkey,{});
                  where = this.groups[innerkey].length-1;
                  this.set("groups."+innerkey+"."+where+".name",this.data[i][innerkey]);
                  this.set("groups."+innerkey+"."+where+".ids",[]);
                  }
                this.push("groups."+innerkey+"."+where+".ids",this.data[i].id);
              }
            }
          }
          this.set("groups.all.0.name","all");
        }
      },

      _maxTotalLinesChanged: function(newValue, oldValue) {
        // to enshure, that a change doesn't crash the data
        var newValue = parseInt(newValue);
        if (newValue && this.data && newValue>0){
          this.maxLines = newValue;
          for (var i=0; i < this.data.length; i++) {
            if (this.data[i].values.length > newValue)
              this.splice("data."+i+".values",newValue,this.data[i].values.length)
          }
        }
        else
          this.maxTotalLines = oldValue;
      }
    });
  });
  </script>

</dom-module>

<script src="../socket.io/socket.io.js"></script>
<dom-module id="data-socket-repeater">
  <script>
  window.addEventListener('WebComponentsReady', function(e) {
    Polymer({
      is: 'data-socket-repeater',

      properties: {
          socketname: {
            type: String,
            value: "/data"
          },
          config: {
            type: Object,
            value: function() {
              return {  "label": "",
                        "firstPattern": {
                          "query": {},
                          "time": { "from": ""},
                          "limit": -10
                        },
                        "appendPattern": {
                          "query": {},
                          "time": { "from": "" },
                          "limit": 0
                        }};
              }
          },
          data: {
            type: Array,
            value: function() { return []; },
            notify: true
          },
          exceeding: {
            type: Array,
            value: function() { return []; },
            notify: true
          },
          ids: {
            type: Array,
            value: function() { return []; },
            notify: true
          },
          labels: {
            type: Array,
            value: function() { return []; },
            notify: true
          },
          availableLabels: {
            type: Array,
            value: function() { return []; },
            notify: true
          },
          groups: {
            type: Array,
            value: function() { return []; },
            notify: true
          },
          groupingKeys: {
            type: Array,
            value: function() { return []; },
            notify: true
          },
          preferedGroupingKeys: {
            type: Array,
            value: function() { return []; },
            notify: true
          },
          keys: {
            type: Array,
            value: function() { return []; }
          },
          unnamedTypes: {
            type: Array,
            value: function() { return []; }
          },
          types: {
            type: Array,
            value: function() { return []; }
          },
          status: {
            type: Object,
            value: function() { return {"message": "...",
                                        "time": {
                                          "lastData": 0,
                                          "lastStatus": 0,
                                          "lastMistake": 0,
                                          "lastError": 0
                                        }}; },
            notify: true
          },
          maxTotalLines: {
            type: Number,
            observer: '_maxTotalLinesChanged',
            value: 100
          },
          maxLines: {
            type: Number,
            value: this.maxTotalLines
          },
          interval: {
            type: Number,
            value: 0
          },
          doAppend: {
            type: Boolean,
            value: true,
            reflectToAttribute: true
          },
          newestDataLast: {
            type: Boolean,
            value: true,
            reflectToAttribute: true
          },
          isExceeding: {
            type: Boolean,
            value: false,
            notify: true
          },
          opened: {
            type: Boolean,
            value: false
          }
      },

      ready: function(){
        this.socket = io.connect('https://'+window.location.host+this.socketname, {secure: true});
        this.set("status.time.lastStatus",new Date()); this.set("status.message", "connecting to "+window.location.host);
        var self = this;
        this.socket.on('clientConfig', function(message) {
          self.set("availableLabels", message.labels);
          self._init();
          if (self.opened)
            self.connect();
        });
      },

      connect: function() {
        // send Config
        this.set("status.time.lastStatus",new Date()); this.set("status.message", "configuring connection");

        // Setting Configuration Request Pattern Array
        var options = { patterns: [] };
        // this.set("config.firstPattern.time.from",new Date()-72000000);
        for (var i=0; i<this.labels.length; i++) {
          options.patterns.push({label: this.labels[i],
                        firstPattern: this.config.firstPattern,
                        appendPattern: this.config.appendPattern});
        }
        // TODO(Hannes): Abfragen funktioniert an Server nicht
        // console.log(JSON.stringify(options));
        this.socket.emit('clientConfig', options);

        var self = this;
        // Receiving the FIRST Data
        this.socket.on('first', function(message) {
          console.info("client has established connection to: "+window.location.host);
          self._onFirstData(message);
        });
        // Receive FURTHER Data
        this.socket.on('data', function(message) {
          self._onData(message);
          // if (message.content[0].values.length !== 1)
            // console.log(message.content[0].values.length);
        });
        // TODO: following senseless?
        // Wrong Data
        this.socket.on('mistake', function() {
          self.set("status.time.lastMistake", new Date());
          console.warn("error in data-connection to: "+window.location.host);
        });
        // Disconnect
        this.socket.on('disconnect', function() {
          self.set("status.time.lastError", new Date());
          console.warn("client disconnected to: "+window.location.host);
        });
        // Disconnect
        this.socket.on('connect_error', function() {
          self.set("status.time.lastError", new Date());
          console.warn("error in connection to: "+window.location.host);
        });
      },

      reconnect: function() {
        this.socket.disconnect();
        this.socket = io.connect('https://'+window.location.host+this.socketname, {secure: true});
        this.set("status.time.lastStatus",new Date()); this.set("status.message", "connecting to "+window.location.host);
        var self = this;
        this.socket.on('clientConfig', function(message) {
          self.set("availableLabels", message.labels);
        });
        this.connect();
      },

      disconnect: function() {
        if (this.socket){
          this.socket.disconnect();
          this._init();
          this.opened = false;
        }
      },

      _init: function() {
        // this.set('data',[]);
        // this.set('groups',[]);
        // this.set('groupingKeys',[]);
        // this.set('preferedGroupingKeys',[]);
        // for (var i=0; i<this.availableLabels.length; i++){
        //   this.push('data',{label: this.availableLabels[i], elements:[]});
        //   this.push('groups',[]);
        //   this.push('groupingKeys',[]);
        //   this.push('preferedGroupingKeys',"all");
        // }
      },

      _onFirstData: function(message) {
        if(message == undefined) { // Check the Existence
          this.set("status.time.lastError", new Date());
          console.warn("received message empty");
          return;
        }
        var time = new Date();
        this.set("status.time.lastStatus", time); this.set("status.message", "processing first data");
        this.set("status.time.lastData", time);

        for (var mesId=0; mesId < message.length; mesId++) {
          // for Polymer (to notice Array change) special treatment to integrate data
          var labelindex = this._getLabelIndex(message[mesId].label);
          this.set("status.message", "setting labels");
          this._setGroupingKeys(labelindex, message[mesId].groupingKeys);
          this._setPreferedGroupingKeys(labelindex, message[mesId].preferedGroupingKey);
          this._setGroups(labelindex, message[mesId].groups);
          this.set("status.message", "init data");
          for (var i = 0; i < message[mesId].content.length; i++) {
            if(message[mesId].content[i].id) {
              this._initDataPoint(labelindex, message[mesId].content[i].id);
              this._setValues(labelindex, message[mesId].content[i]);
            }
          }
        }
        this.set("status.time.lastStatus", new Date()); this.set("status.message", "loaded");
        if (!this.opened ) {
          this.fire("loaded");
          this.opened = true;
        }
      },

      _onData: function(message) {
        if(message == undefined) return; // Check for Existence
        var time = new Date();
        if (time - this.status.time.lastData >= this.interval) { // TODO: Configure it at server
          this.set("status.time.lastData", time);
          if (Array.isArray(message)){ // if message is an Array
            for (var mesId=0; mesId < message.length; mesId++) {
              var labelindex = this._getLabelIndex(message[mesId].label);
              // important: set label serverside for each sent object
              //            alse not checked if labels are not selected for effiency
              for (var i in message[mesId].content) { // for all messurement-data-alements existing
                if(message[mesId].content[i].id) {
                  this._setValues(labelindex, message[mesId].content[i]);
                }
              }
            }
          }
          else { // if message is a single Object
            var labelindex = this._getLabelIndex(message.label);
            for (var i in message.content) { // for all messurement-data-alements existing
              if(message.content[i].id) {
                this._setValues(labelindex, message.content[i]);
              }
            }
          }
        }
      },

      _getIndex: function(labelindex, id) {
        var check;
        if(this.ids && this.ids[labelindex])
          var check = this.ids[labelindex].indexOf(id);
        if(check !== undefined && this.ids[labelindex].indexOf(id) !== -1)
          return check;
        else // if it doesn't excist then return undefined
          return undefined;
      },

      _getLabelIndex: function(labelName) {
        if (this.labels.indexOf(labelName) != -1 && this.availableLabels.indexOf(labelName) != -1)
          return this.availableLabels.indexOf(labelName);
        else // if it isn't selected then return undefined
          return undefined;
      },

      _getLabelName: function(labelindex) {
        return this.availableLabels[labelindex];
      },

      _setGroupingKeys: function(labelindex, groupingKeys) {
        while (labelindex >= this.groupingKeys.length)
          this.push("groupingKeys", {});
        this.set("groupingKeys."+labelindex, groupingKeys);
      },

      _setPreferedGroupingKeys: function(labelindex, preferedGroupingKey) {
        while (labelindex >= this.preferedGroupingKeys.length)
          this.preferedGroupingKeys.push("all");
        this.preferedGroupingKeys[labelindex] = preferedGroupingKey;
      },

      _setGroups: function(labelindex, groups) {
        while (labelindex >= this.groups.length)
          this.push("groups", {});
        this.set("groups."+labelindex, {label: this.availableLabels[labelindex], groups: groups});
      },

      _setValues: function(labelindex, messageContent) {
        // getting positions for the ids in groups
        // TODO: optimize
        var id = messageContent.id;
        var a, b, c;
        for (a = 0; a < this.groups[labelindex].groups.length; a++) {
          if(this.groups[labelindex].groups[a].key == this.preferedGroupingKeys[labelindex])
            break;
        }
        for (b = 0; b < this.groups[labelindex].groups[a].subgroup.length; b++) {
          c = this.groups[labelindex].groups[a].subgroup[b].ids.indexOf(id);
          if(c !== -1)
            break;
        }

        if (!this.doAppend)
          this.splice('groups.' + labelindex + '.groups.' + a + '.subgroup.' + b + '.elements.' + c + '.values',0,this.groups[labelindex].groups[a].subgroup[b].elements[c].values.length);
        if (this.newestDataLast) {
          for (var j = 0; j < messageContent.values.length; j++) {
            this.unshift('groups.' + labelindex + '.groups.' + a + '.subgroup.' + b + '.elements.' + c + '.values', messageContent.values[j]);
            this._checkIfExceedingStateHasToBeSet(labelindex, a, b, c, messageContent.values[j].exceeds);
          }
        }
        else {
          for (var j = messageContent.values.length-1; j >=0; j--) {
            this.unshift('groups.' + labelindex + '.groups.' + a + '.subgroup.' + b + '.elements.' + c + '.values', messageContent.values[j]);
            this._checkIfExceedingStateHasToBeSet(labelindex, a, b, c, messageContent.values[j].exceeds);
          }
        }
        if (this.groups[labelindex].groups[a].subgroup[b].elements[c].values.length > this.maxLines)
          this.splice('groups.' + labelindex + '.groups.' + a + '.subgroup.' + b + '.elements.' + c + '.values', this.maxLines, this.data[labelindex][i].values.length - this.maxLines);

        // if (messageContent.lastExceeds)
        //   this.set('groups.' + labelindex + '.groups.' + a + '.subgroup.' + b + '.elements.' + c + '.values', messageContent.lastExceeds);
      },

      // init datapoint, but it doesn't overwrite datavalues, if the datapoint existed before and has matching labels
      _initDataPoint: function(labelindex, id) {
        // TODO: optimize
        var a, b, c;
        for (a = 0; a < this.groups[labelindex].groups.length; a++) {
          if(this.groups[labelindex].groups[a].key == this.preferedGroupingKeys[labelindex])
            break;
        }
        for (b = 0; b < this.groups[labelindex].groups[a].subgroup.length; b++) {
          c = this.groups[labelindex].groups[a].subgroup[b].ids.indexOf(id);
          if(c !== -1)
            break;
        }
        this.splice('groups.' + labelindex + '.groups.' + a + '.subgroup.' + b + '.elements.' + c + '.values', 1, this.groups[labelindex].groups[a].subgroup[b].elements[c].values.length - 1);
      },

      _checkIfExceedingStateHasToBeSet: function(labelindex, a, b, c, exceeds) {
        if(this.groups[labelindex].groups[a].subgroup[b].elements[c].isExceeding == undefined)
          this.groups[labelindex].groups[a].subgroup[b].elements[c].isExceeding = null;
        if (exceeds === null) {
          if(this.groups[labelindex].groups[a].subgroup[b].elements[c].isExceeding === true) {
            this.set('groups.' + labelindex + '.groups.' + a + '.subgroup.' + b + '.elements.' + c + ".isExceeding", false);
            this._removeExceedingElement(labelindex, a, b, c);
          }
        }
        else if (exceeds === true || exceeds === false) {
          // TODO: check if this could be optimized
          var item = Polymer.Collection.get(this.groups[labelindex].groups[a].subgroup[b].elements).getItem('#'+c);
          var key = Polymer.Collection.get(this.exceeding).getKey(item);
          if(item && key) {
            this.push('exceeding', item);
            this.linkPaths('exceeding.' + key, 'groups.#' + labelindex + '.groups.#' + a + '.subgroup.#' + b + '.elements.#' + c);
            this.set("isExceeding", true);
            this.set('groups.' + labelindex + '.groups.' + a + '.subgroup.' + b + '.elements.' + c + ".isExceeding", true);
          }
        }
      },

      _removeExceedingElement: function(labelindex, a, b, c) {
        var item = Polymer.Collection.get(this.groups[labelindex].groups[a].subgroup[b].elements).getItem('#'+c);
        var key = Polymer.Collection.get(this.exceeding).getKey(item);
        if(item && key) {
          this.arrayDelete('exceeding', item);
          this.unlinkPaths('exceeding.' + key);
          if (this.exceeding.length == 0)
            this.set("isExceeding",false);
        }
      },

      _maxTotalLinesChanged: function(newValue, oldValue) {
        // to enshure, that a change doesn't crash the data
        var newValue = parseInt(newValue);
        if (newValue && this.data && newValue>0){
          this.maxLines = newValue;
          for (var labelindex=0; labelindex < this.data.length; labelindex++) {
            for (var i=0; i < this.data[labelindex].length; i++) {
              if (this.data[labelindex][i].values.length > newValue)
                this.splice("data." + labelindex + "." + i + ".values", newValue,this.data[labelindex][i].values.length)
            }
          }
        }
        else
          this.maxTotalLines = oldValue;
      }
    });
  });
  </script>

</dom-module>

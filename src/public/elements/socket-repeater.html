<dom-module id="socket-repeater">

  <script>
  HTMLImports.whenReady(function() {
    Polymer({
      is: 'socket-repeater',

      properties: {
          socket: {
            type: String,
            value: "/data",
            notify: true
          },
          lastData: {
            type: Array,
            value: function() { return []; },
            notify: true
          },
          lastExceeds: {
            type: Array,
            value: function() { return []; },
            notify: true
          },
          lastMessage: {
            type: Date,
            value: 0,
            notify: true
          },
          lastMistake: {
            type: Date,
            value: 0,
            notify: true
          },
          lastError: {
            type: Date,
            value: 0,
            notify: true
          },
          maxTotalLines: {
            type: Number,
            value: 2,
            observer: 'maxTotalLinesChanged'
          },
          doAppend: {
            type: Boolean,
            value: false,
            notify: true
          },
          groups: {
            type: Object,
            value: function() { return {}; },
            notify: true
          }
      },

      ready: function(){
        var self = this;
        var dataSocket = io.connect('https://'+window.location.host+this.socket, {secure: true});
        // Receiving the first Data
        dataSocket.on('first', function(message) {
          var message = message;
          if(message === undefined || message.content === undefined) return; // Check the Existence

          self.lastMessage = message.time;
          var k, values;
          for (var i=0; i < message.content.length; i++) {
            self.push("lastData",{"id":message.content[i].id,
                                  "roomNr":message.content[i].roomNr,
                                  "room":message.content[i].room,
                                  "kind":message.content[i].kind,
                                  "method":message.content[i].method,
                                  "unit":message.content[i].unit,
                                  "threshold":message.content[i].threshold,
                                  "isBoolean":message.content[i].isBoolean,
                                  "values":[]
                                  });
            k = 0;
            if (message.content[i].values.length > self.maxTotalLines)
              k = message.content[i].values.length - self.maxTotalLines;
            for (var j=k; j < message.content[i].values.length; j++) {
              self.unshift("lastData."+i+".values",message.content[i].values[j]);
            }
          }
          self.lastExceeds = message.lastExceeds;
          self.groups = message.groups;
        });

        // Receive another Data
        dataSocket.on('data', function(message) {
          if(message === undefined || message.content === undefined) return; // Check for Existence

          self.lastMessage = null;
          self.lastExceeds = null;
          self.lastMessage = message.time;
          self.lastExceeds = message.lastExceeds;

          var k = 0;

          if (self.doAppend){
              for (var i=0; i < self.lastData.length; i++) {
                while (message.content[i].values.length + self.lastData[i].values.length > self.maxTotalLines && self.lastData[i].values.length > 0)
                  self.pop("lastData."+i+".values");
                k = 0;
                if (message.content[i].values.length > self.maxTotalLines)
                  k = message.content[i].values.length - self.maxTotalLines;
                for (var j=k; j < message.content[i].values.length; j++) {
                  self.unshift("lastData."+i+".values",message.content[i].values[j]);
                }
              }
          }
          else {
            for (var i=0; i < self.lastData.length; i++) {
              while (self.lastData[i].values.length > 0)
                self.pop("lastData."+i+".values");
              var k = 0;
              if (message.content[i].values.length > self.maxTotalLines)
                k = message.content[i].values.length - self.maxTotalLines;
              for (var j=k; j < message.content[i].values.length; j++) {
                self.unshift("lastData."+i+".values",message.content[i].values[j]);
              }
            }
          }
        });

        //*** Wrong Data
        dataSocket.on('mistake', function(message) {
          self.lastMistake = message.time;
          self.lastError = message.error;
        });

      },

      maxTotalLinesChanged: function(newValue, oldValue) {
        if (this.lastData && newValue < oldValue && newValue>0)
          for (var i=0; i < this.lastData.length; i++) {
            while (this.lastData[i].data.length > newValue)
              this.shift("lastData."+i+".data");
          }
      }
    });
  });
  </script>

</dom-module>

<link rel="import" href="../bower_components/polymer/polymer.html">
<link href="../bower_components/paper-ripple/paper-ripple.html" rel="import">

<!--  D3.js and NVD3 import -->
<script src="../js/d3/d3.min.js" charset="utf-8"></script>
<script src="../js/nvd3/build/nv.d3.min.js"></script>

<polymer-element name="value-graph">
  <template>
    <link href="../js/nvd3/build/nv.d3.css" rel="stylesheet" type="text/css">
    <style>
      :host {
        position: relative;
        color: #1d1d1d;
        overlay: hidden;
        z-index: 0;
        outline: none;
        user-select: none;
      }
      div {
        padding: none;
        margin: none;
        position: relative;
      }
      .nvd3 text, .title, .nvtooltip {
        font-size: 0.9em;
        font-family: Roboto-Condensed-Light;
      }
      .nv-axis {
        font-size: 0.95em;
      }
      text.nv-axislabel {
        font-size: 1.25em;
      }
      .nvtooltip {
        margin-top: 0px;
        margin-left: -47vmin;
        background: white;
      }

    </style>
    <div>
      <svg id="svg"></svg>
    </div>

  </template>

  <script>

  Polymer('value-graph', {
      publish: {
        values: [],
        data: [{"var":"mode",
                "unit":"unit",
                "key":"measurement",
                "values":[{"x":new Date("01/01/2015 00:00:00"),"y":0}]
              }],
        /**
         * If true, masks lines within the X and Y scales using a clip-path.
         *
         * @attribute clipEdge
         * @type boolean
         */
        clipEdge: false,

        /**
         * Colors to use for the different data. If an array is given,
         * it is converted to a function automatically.
         *
         * @attribute color
         * @type array or function
         */
        color: nv.utils.defaultColor(),

        /**
         * A provided function that allows a line to be non-continuous
         * when not defined.
         * https://github.com/mbostock/d3/wiki/SVG-Shapes#line_defined
         *
         * @attribute defined
         * @type function
         */
        defined: null,

        /**
         * Duration in ms to take when updating chart. For things like
         * bar charts, each bar can animate by itself but the total
         * time taken should be this value.
         *
         * @attribute duration
         * @type number
         */
        duration: 200,

        /**
         * Like forceX and forceY, this forces certain values onto the
         * point scale.
         *
         * @attribute forcePoint
         * @type number
         */
        forcePoint: [],

        /**
         * List of numbers to Force into the X scale (ie. 0, or a
         * max / min, etc.). This ensures the numbers are in the X
         * domain but doesn't override the whole domain. This option
         * only applies if you have not overridden the whole domain
         * with the xDomain option.
         *
         * @attribute forceX
         * @type array
         */
        forceX: [],

        /**
         * List of numbers to Force into the Y scale (ie. 0, or a
         * max / min, etc.). This ensures the numbers are in the Y
         * domain but doesn't override the whole domain. This option
         * only applies if you have not overridden the whole domain
         * with the yDomain option.
         *
         * @attribute forceY
         * @type array
         */
        forceY: [],

        /**
         * Controls the line interpolation between points, many options
         * exist, see the D3 reference:
         * https://github.com/mbostock/d3/wiki/SVG-Shapes#line_interpolate
         *
         * @attribute interpolate
         * @type string
         */
        interpolate: "monotone",

        /**
         * Function to define if a line is a normal line or if it fills
         * in the area. Notice the default gets the value from the
         * line's definition in data. If a non-function is given, it the
         * value is used for all lines.
         *
         * @attribute isArea
         * @type function or boolean
         */
        isArea: function(d) { return d.area },

        /**
         * When only one Y axis is used, this puts the Y axis on the
         * right side instead of the left.
         *
         * @attribute rightAlignYAxis
         * @type boolean
         */
        rightAlignYAxis: false,

        /**
         * Whether to display the legend or not.
         *
         * @attribute showLegend
         * @type boolean
         */
        showLegend: false,

        /**
         * Display or hide the X Axis.
         *
         * @attribute showXAxis
         * @type boolean
         */
        showXAxis: true,

        /**
         * Display or hide the Y Axis.
         *
         * @attribute showYAxis
         * @type boolean
         */
        showYAxis: true,

        /**
         * Function used to build the tooltip content. The variables
         * passed to the function can depend on the chart (i.e. it
         * depends on what makes sense for the chart) so you might want
         * to console.log stuff when playing with this to see what's
         * available.
         * The default is null because then the tooltip will be the
         * NVD3's default.
         *
         * @attribute tooltipContent
         * @type function
         * @default null
         */
        tooltipContent: null,

        /**
         * Whether to display tooltips or not.
         *
         * @attribute tooltips
         * @type boolean
         */
        tooltips: true,

        /**
         * Sets the chart to use a guideline and floating tooltip
         * instead of requiring the user to hover over specific
         * hotspots. Turning this on will set the 'interactive' and
         * 'useVoronoi' options to false to avoid conflicting.
         *
         * @attribute useInteractiveGuideline
         * @type boolean
         */
        useInteractiveGuideline: true,

        /**
         * Proxy function to return the X value so adjustments can be
         * made if needed. For pie/donut chart this returns the key
         * for the slice.
         * The default is null because then the x value will be the
         * NVD3's default.
         *
         * @attribute x
         * @type function
         * @default null
         */
        x: null,

        /**
         * Proxy function to return the Y value so adjustments can be
         * made if needed. For pie/donut chart this returns the value
         * for the slice.
         * The default is null because then the y value will be the
         * NVD3's default.

         * @attribute y
         * @type function
         * @default null
         */
        y: null,

        /**
         * The label of the x axis.
         *
         * @attribute xAxisAxisLabel
         * @type string
         * @default ''
         */
        xAxisAxisLabel: '',

        /**
         * Angle (in degrees) to rotate the x axis labels.
         *
         * @attribute xAxisRotateLabels
         * @type number
         * @default 0
         */
        xAxisRotateLabels: 0,

        /**
         * Tick format of the x axis.
         *
         * @attribute xAxisTickFormat
         * @type Object
         */
        xAxisTickFormat:  function(d) {
          return d3.time.format('%d.%m.%Y %H:%M:%S')(new Date(d)); },

        /**
         * The label of the y axis.
         *
         * @attribute yAxisAxisLabel
         * @type string
         * @default ''
         */
        yAxisAxisLabel: '',

        /**
         * Angle (in degrees) by which the y axis labels will be rotated.
         *
         * @attribute yAxisRotateLabels
         * @type number
         * @default 0
         */
        yAxisRotateLabels: 0,

        /**
         * Tick format of the y axis.
         *
         * @attribute yAxisTickFormat
         * @type Object
         */
        yAxisTickFormat: function(d) { return d3.format('.2f')(d); }
      },
      // SOURCE: https://github.com/nvd3-community/nvd3
      // TODO: look up
      // https://github.com/RenatoUtsch/poly-nvd3/blob/master/nvd3-abstract-chart/nvd3-abstract-chart.html
      // http://busypeoples.github.io/post/d3-polymer-elements/

      created: function() {
        this.chart = null;
        this.svg = null;
        this.data = this.data || [];
        this.margin = this.margin || { top: 30, right: 50, bottom: 30, left: 50 };
      },

      ready: function() {
        this.svg = d3.select(this.$.svg);
        this.manageDataFromUrl();
        this.createChart();
      },

      domReady: function() {
        this.updateData();
      },

      createChart: function() {
        var self = this;

        nv.addGraph(function() {
          self.chart = nv.models.lineChart();
          self.setUp();
          self.updateData();
          return self.chart;
        });
      },

      setUp: function() {
        this.chart
          .margin(this.margin)
          .clipEdge(this.clipEdge)
          .color(this.color)
          .duration(this.duration)
          .forcePoint(this.forcePoint)
          .forceX(this.forceX)
          .forceY(this.forceY)
          .interpolate(this.interpolate)
          .isArea(this.isArea)
          .rightAlignYAxis(this.rightAlignYAxis)
          .showLegend(this.showLegend)
          .showXAxis(this.showXAxis)
          .showYAxis(this.showYAxis)
          .tooltips(this.tooltips)
          .useInteractiveGuideline(this.useInteractiveGuideline);

        if(this.defined)
          this.chart.defined(this.defined);
        if(this.tooltipContent)
          this.chart.tooltipContent(this.tooltipContent);
        if(this.x)
          this.chart.x(this.x);
        if(this.y)
          this.chart.y(this.y);

        this.chart.xAxis
          .axisLabel(this.xAxisAxisLabel)
          .rotateLabels(this.xAxisRotateLabels)
          .tickFormat(this.xAxisTickFormat)
          ;
        //
        // this.chart
        //   .selectAll('g.x.axis g text')
        //   .call(wrap);
        //
        //   function wrap(text, width) {
        //     text.each(function() {
        //       var text = d3.select(this),
        //           words = text.text().split(''),
        //           word,
        //           line = [],
        //           lineNumber = 0,
        //           lineHeight = 1.1, // ems
        //           y = text.attr("y"),
        //           dy = parseFloat(text.attr("dy")),
        //           tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
        //       while (word = words.pop()) {
        //         line.push(word);
        //         tspan.text(line.join(" "));
        //         if (tspan.node().getComputedTextLength() > width) {
        //           line.pop();
        //           tspan.text(line.join(" "));
        //           line = [word];
        //           tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
        //         }
        //       }
        //     });
        //   }
          //
          // var insertLinebreaks = function (d) {
          //     var el = this.svg;
          //     var words = d.split(' ');
          //     el.text('');
          //
          //     for (var i = 0; i < words.length; i++) {
          //         var tspan = el.append('tspan').text(words[i]);
          //         if (i > 0)
          //             tspan.attr('x', 0).attr('dy', '15');
          //     }
          // };




        this.chart.yAxis
          .axisLabel(this.yAxisAxisLabel)
          .rotateLabels(this.yAxisRotateLabels)
          .tickFormat(this.yAxisTickFormat);
      },

      updateData: function() {
        if(this.svg && this.chart) {
          this.svg
            .datum(this.data)
            .call(this.chart);
          nv.utils.windowResize(this.chart.update);
        }
      },

      valuesChanged: function() {
        this.data = [{"key": this.values.var + " (" + this.values.unit + ")",
                      "values":[],
                      "area" : true
                     }];
        for (i=0; i< this.values.data.length; i++)
          this.data[0].values.push(
            {"x": new Date(this.convertDateString(this.values.data[i].date)),
             "y": this.values.data[i].value});
        this.createChart();
        // this.updateData();
      },

      convertDateString: function(d) {
        var s = d.split(' ');
        var day = s[0].split('.');
        return (day[2]+'/'+
                day[1]+'/'+
                day[0]+' '+
                s[1]);
      },

      urlChanged: function(oldValue, newValue) {
        this.manageDataFromUrl();
      },

      manageDataFromUrl: function() {
        var self = this;

        if(this.url) {
          // Get the data from the url and set it as the current data.
          var ajax = this.shadowRoot.querySelector('core-ajax');
          ajax.addEventListener('core-response', function(e) {
            self.url = ''; // Clean up the request.
            self.data = e.detail.response;
          });
          ajax.go();
        }
      }

  });


  </script>
</polymer-element>
